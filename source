if rawequal(game:IsLoaded(), false) then
	game.Loaded:Wait()
end

task.wait(.5)

if _G.loadedopadminalruscrub then return end
_G.loadedopadminalruscrub = true

setfpscap = setfpscap or function() end
setfps = setfps or function() end
getgenv = getgenv or (warn('not usable | getgenv') or getfenv)
fireproximityprompt = fireproximityprompt or function() end
firetouchinterest = firetouchinterest or function() end
setclipboard = setclipboard or function() end
saveinstance = saveinstance or function() end
hookmetamethod = hookmetamethod or function() end

local z;z = {
	core_gui = game:GetService('CoreGui'),
	debris = game:GetService('Debris'),
	tween_service = game:GetService('TweenService'),
	players = game:GetService('Players'),
	run_service = game:GetService('RunService'),
	starter_player = game:GetService('StarterPlayer'),
	teleport_service = game:GetService('TeleportService'),
	text_chat_service = game:GetService('TextChatService'),
	lighting = game:GetService('Lighting'),
	user_input_service = game:GetService('UserInputService'),
	replicated_storage = game:GetService('ReplicatedStorage'),
	http = game:GetService('HttpService'),

	allow_command_switching = true,
	connect = game.Changed.Connect,
	destroy = game.Destroy,
	empty = function() end,
	local_player = game:GetService('Players').LocalPlayer,
	highlights = {},
}

local maid;maid = {
	_tasks = {},
	_cleaner = z.connect(z.run_service.Stepped, function()
		for name, task in pairs(maid._tasks) do
			if typeof(task) == 'RBXScriptConnection' and not task.Connected and not name:find('$PROTECTED') then
				maid._tasks[name] = nil
			end
		end
	end),

	add = function(name, signal, fn, important)
		if maid._tasks[name] then
			maid:remove(name)
		end
		if important == 1 then
			maid._tasks[name..'$PROTECTED'] = z.connect(signal, fn)
		else
			maid._tasks[name] = z.connect(signal, fn)
		end
	end,

	remove = function(name)
		local task = maid._tasks[name]
		if task then
			if typeof(task) == 'RBXScriptConnection' and task.Connected and not name:find('$PROTECTED') then
				z.disconnect(task)
				maid._tasks[name] = nil
			end
		end
	end,

	clean = function()
		for name, task in pairs(maid._tasks) do
			if typeof(task) == 'RBXScriptConnection' and task.Connected and not name:find('$PROTECTED')  then
				z.disconnect(task)
				maid._tasks[name] = nil
			end
		end

		table.clear(maid._tasks)
		maid._tasks = {}
	end,
}

do
	local connection = z.connect(game.Changed, z.empty)
	z.disconnect = connection.Disconnect
	z.disconnect(connection)

	z.local_character = z.local_player.Character or z.local_player.CharacterAdded:Wait()
	z.default_walkspeed = z.local_character:WaitForChild('Humanoid').WalkSpeed or z.starter_player.CharacterWalkSpeed
	z.default_jumppower = z.local_character:WaitForChild('Humanoid').JumpPower or z.starter_player.CharacterJumpPower
	pcall(function()
		z.is_mobile = table.find({Enum.Platform.IOS, Enum.Platform.Android}, game:GetService('UserInputService'):GetPlatform())
	end)
	maid.add('local_character_added', z.local_player.CharacterAdded, function(character)
		z.local_character = character
	end,1)

	maid.add('clean_highlights', z.run_service.Stepped, function()
		for _, plr in pairs(z.players:GetPlayers()) do
			local highlight = z.highlights[plr]
			if highlight and not (highlight.Adornee and highlight.Adornee:IsDescendantOf(workspace)) then
				pcall(z.destroy, highlight)
				z.highlights[plr] = nil
			end
		end
	end,1)
end

local ui = game:GetObjects('rbxassetid://102338830611620')[1]:Clone()
local commands_gui = ui.commands_ui:Clone()
local notif_gui = ui.notification_ui:Clone()
local chatlog_gui = ui.chat_logs:Clone()
chatlog_gui.Name = 'chat_logs'
if not ui then return error('failed to get gui') end
local search_box = commands_gui.main_container:WaitForChild('search')
local commands_container = commands_gui.main_container:WaitForChild('commands')
do
	commands_gui:WaitForChild('main_container')
	local x_button = commands_gui.main_container:WaitForChild('close')
	local search_box = commands_gui.main_container:WaitForChild('search')
	local commands_container = commands_gui.main_container:WaitForChild('commands')

	maid.add('close_button_MouseButton1Up', x_button.MouseButton1Up, function()
		commands_gui.Enabled = false
	end, 1)

	maid.add('command_search', search_box:GetPropertyChangedSignal('Text'), function()
		local search_text = search_box.Text:lower()

		for _, label in pairs(commands_container:GetChildren()) do
			if label:IsA('TextLabel') then
				if search_text == '' then
					label.Visible = true
				else
					local command_names = label.Text:split(':')[1]:lower()

					local found = false
					for _, name in pairs(command_names:split(',')) do
						local trimmed_name = name:gsub('^%s*(.-)%s*$', '%1')
						if trimmed_name:find('^' .. search_text) or trimmed_name == search_text then
							found = true
							break
						end
					end

					label.Visible = found
				end
			end
		end
	end, 1)

	maid.add('command_search_focus', search_box.Focused, function()
		search_box.PlaceholderText = 'type to search...'
	end, 1)

	maid.add('command_search_unfocus', search_box.FocusLost, function()
		if search_box.Text == '' then
			search_box.PlaceholderText = 'search commands'
		end
	end, 1)

	commands_gui.Parent = z.core_gui
	notif_gui.Parent = z.core_gui
	commands_gui.Enabled = false
end

local notif_list = notif_gui.main_container
local notif_template = notif_list:WaitForChild('template'):Clone()
local command_template = commands_gui.main_container:WaitForChild('commands'):WaitForChild('template'):Clone()
local chat_log_template = chatlog_gui.main_container:WaitForChild('chatlogs'):WaitForChild('log'):Clone()
pcall(z.destroy, notif_list.template)
pcall(z.destroy, commands_gui.main_container:WaitForChild('commands'):WaitForChild('template'))
pcall(z.destroy, chatlog_gui.main_container:WaitForChild('chatlogs'):WaitForChild('log'))

-- function slop

local hypernull;hypernull = function(fn, ...)
	if(coroutine.status(task.spawn(hypernull,fn,...)) == 'dead')then return end
	fn(...)
end

local active_notifications = {}
local max_notifications = 10

local function remove_notification(text_label)
	local tween_info = TweenInfo.new(.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)

	local tween = z.tween_service:Create(text_label, tween_info, {
		BackgroundTransparency = 1,
		TextTransparency = 1
	})

	tween:Play()
	tween.Completed:Connect(function()
		for i, notif in ipairs(active_notifications) do
			if notif.label == text_label then
				table.remove(active_notifications, i)
				break
			end
		end
		text_label:Destroy()
	end)
end

local function remove_oldest_notification()
	if #active_notifications > 0 then
		local oldest = active_notifications[1]
		if oldest.timer then
			task.cancel(oldest.timer)
		end
		remove_notification(oldest.label)
	end
end

local notify = function(text)
	if #active_notifications >= max_notifications then
		remove_oldest_notification()
	end

	local text_label = notif_template:Clone()
	local tween_info = TweenInfo.new(.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)

	text_label.Parent = notif_list
	text_label.Visible = true
	text_label.Text = ` {text} `
	text_label.BackgroundTransparency = 1
	text_label.TextTransparency = 1

	z.tween_service:Create(text_label, tween_info, {
		BackgroundTransparency = .1,
		TextTransparency = 0
	}):Play()

	local notification_data = {
		label = text_label,
		created_at = tick(),
		timer = nil
	}

	table.insert(active_notifications, notification_data)

	notification_data.timer = task.delay(4, function()
		remove_notification(text_label)
	end)
end

local parse_hex = function(hex)
	if not (hex and hex:sub(1, 1) == '#' and #hex == 7) then return end

	local r = tonumber(hex:sub(2, 3), 16)
	local g = tonumber(hex:sub(4, 5), 16)
	local b = tonumber(hex:sub(6, 7), 16)

	return r and g and b and Color3.fromRGB(r, g, b)
end

local get_plr = function(name)
	if not name then
		return {}
	end

	local lower_name = name:lower()
	local all_plrs = z.players:GetPlayers()

	if lower_name == '@random' then
		return {all_plrs[math.random(#all_plrs)]}
	elseif lower_name == '@me' then
		return {z.local_player}
	elseif lower_name == '@all' then
		return all_plrs		
	elseif lower_name == '@others' then
		local others = {}
		for _, plr in next, all_plrs do
			if plr ~= z.local_player then
				table.insert(others, plr)
			end
		end
		return others
	elseif lower_name == '@view' then
		return {z.players:GetPlayerFromCharacter(workspace.CurrentCamera.CameraSubject.Parent)}
	end

	lower_name = lower_name:gsub('%s', '')
	for _, plr in next, all_plrs do
		if plr.Name:lower():match(lower_name) or plr.DisplayName:lower():match('^' .. lower_name) then
			return {plr}
		end
	end
end

local predict_movement = function(player, future)
	local char = player.Character
	if not char then return end

	local hrp = char:FindFirstChild('HumanoidRootPart')
	local humanoid = char:FindFirstChild('Humanoid')
	if not (hrp and humanoid) then return end

	local move_dir = humanoid.MoveDirection
	if move_dir == Vector3.zero then
		return hrp.CFrame
	end

	return hrp.CFrame + move_dir * future
end

local network_check = function(part)
	return part.ReceiveAge == 0
end

local get_closest_part = function()
	local best_part, smallest_mag
	local head_pos = z.local_character.Head.Position

	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA('BasePart') and not v.Anchored and #v:GetConnectedParts() < 2 then
			if not v.Parent:FindFirstChildOfClass('Humanoid') and not v.Parent.Parent:FindFirstChildOfClass('Humanoid') and not v:IsDescendantOf(z.local_character) then
				local mag = (head_pos - v.Position).Magnitude
				if not smallest_mag or mag < smallest_mag then
					smallest_mag, best_part = mag, v
				end
			end
		end
	end

	return best_part
end

local get_closest_player = function(fov)
	local mouse = z.local_player:GetMouse()
	local closest_player, closest_distance = nil, fov

	for _, plr in pairs(z.players:GetPlayers()) do
		if plr ~= z.local_player and plr.Character and plr.Character:FindFirstChild('Head') then
			local head = plr.Character.Head
			local screen_pos, on_screen = workspace.CurrentCamera:WorldToScreenPoint(head.Position)

			if on_screen then
				local mouse_distance = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screen_pos.X, screen_pos.Y)).Magnitude

				if mouse_distance < closest_distance then
					closest_distance = mouse_distance
					closest_player = plr
				end
			end
		end
	end

	return closest_player
end

local cmd_library;cmd_library = {
	_commands = {},

	add = function(names, description, fn)
		table.insert(cmd_library._commands, {
			names = names,
			description = description,
			fn = fn,
			variable_storage = {}
		})
	end,

	get_variable_storage = function(name)
		for _, v in next, cmd_library._commands do
			for _, cmd in next, v.names do
				if cmd:lower() == name:lower() then
					return v.variable_storage
				end
			end
		end
	end,

	execute = function(name, ...) 
		local found = false
		local vargs = {...}

		for _, v in pairs(cmd_library._commands) do
			for _, cmd in next, v.names do
				if cmd:lower() == name:lower() then
					found = true
					task.spawn(function()
						xpcall(function()
							v.fn(v.variable_storage, unpack(vargs))
						end, warn)
					end)
					break
				end
			end
		end

		if not found then
			notify(`couldn't find command named '{name and tostring(name) or ''}'`)
		end
	end,
}

--[[
cmd_library.add({'alias1', 'alias2'}, 'description', function(variable_storage, ...)

end)
]]

cmd_library.add({'rejoin', 'rj'}, 'rejoins the server', function()
	notify('now rejoining')
	z.teleport_service:TeleportToPlaceInstance(game.PlaceId, game.JobId, z.local_player)
end)

cmd_library.add({'esp', 'playeresp', 'toggleesp'}, `toggles esp. optional args: 'team' for team colors, '#RRGGBB' for custom color`, function(vstorage, color)
	vstorage.enabled = not vstorage.enabled
	vstorage.team = color == 'team'
	vstorage.color = (not vstorage.team and parse_hex(color)) or vstorage.color or Color3.new(1, 1, 1)

	if vstorage.enabled then
		notify('esp enabled')
	else
		notify('esp disabled')

		for _, plr in pairs(z.players:GetPlayers()) do
			if plr.Character then
				local head = plr.Character:FindFirstChild('Head')
				if head then
					local esp_gui = head:FindFirstChild('ESPThingYes')
					if esp_gui then
						pcall(z.destroy, esp_gui)
					end
				end

				if z.highlights[plr] then
					pcall(z.destroy, z.highlights[plr])
					z.highlights[plr] = nil
				end
			end
		end
	end
end)

maid.add('esp_update', z.run_service.RenderStepped, function()
	local esp_vs = cmd_library.get_variable_storage('esp')
	if not esp_vs.enabled then return end

	for _, plr in pairs(z.players:GetPlayers()) do
		local char = plr.Character
		if plr ~= z.local_player and char and char:FindFirstChild('Head') then
			local head = char.Head

			local esp_billboard = head:FindFirstChild('ESPThingYes')
			if not esp_billboard then
				esp_billboard = Instance.new('BillboardGui')
				esp_billboard.Name = 'ESPThingYes'
				esp_billboard.Size = UDim2.new(0, 150, 0, 50)
				esp_billboard.StudsOffset = Vector3.new(0, 2, 0)
				esp_billboard.AlwaysOnTop = true
				esp_billboard.Parent = head

				local text_label = Instance.new('TextLabel')
				text_label.Name = 'ESPText'
				text_label.Size = UDim2.new(1, 0, 1, 0)
				text_label.BackgroundTransparency = 1
				text_label.TextScaled = true
				text_label.TextStrokeTransparency = 0
				text_label.Parent = esp_billboard
			end

			local text_label = esp_billboard:FindFirstChild('ESPText')
			local coords = char.PrimaryPart and char.PrimaryPart.Position or Vector3.new(0, 0, 0)
			text_label.Text = string.format('%s\nX:%d Y:%d Z:%d', plr.Name, coords.X, coords.Y, coords.Z)

			local color = esp_vs.team and 
				(plr.Team == z.local_player.Team and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)) or 
				esp_vs.color

			text_label.TextColor3 = color

			local highlight = z.highlights[plr]
			if not highlight then
				highlight = Instance.new('Highlight')
				highlight.Adornee = char
				highlight.FillColor = color
				highlight.OutlineColor = Color3.new(0, 0, 0)
				highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
				highlight.Parent = workspace
				z.highlights[plr] = highlight
			else
				highlight.FillColor = color
			end
		end
	end
end,1)

cmd_library.add({'chatlogs', 'cl'}, 'toggles the chatlogs', function(vstorage)
	local existing_log = z.core_gui:FindFirstChild('chat_logs')

	if existing_log then
		z.text_chat_service.OnIncomingMessage = z.empty
		pcall(z.destroy, existing_log)
		vstorage.logsexecuted = false
		notify('chatlogs disabled')
		return
	end

	vstorage.logsexecuted = true
	local chatlog = chatlog_gui:Clone()
	chatlog.Parent = z.core_gui

	if z.text_chat_service.ChatVersion == Enum.ChatVersion.TextChatService then
		z.text_chat_service.OnIncomingMessage = function(message)
			if message.Status == Enum.TextChatMessageStatus.Success then
				local frame = chatlog:FindFirstChildOfClass('Frame')
				local sframe = frame:FindFirstChildOfClass('ScrollingFrame')
				local label = chat_log_template:Clone()

				label.Name = tostring(message.Text)
				label.Visible = true
				label.Text = tostring(message.TextSource) .. ': ' .. tostring(message.Text)
				label.Parent = sframe

				task.wait()
				sframe.CanvasPosition = Vector2.new(0, sframe.AbsoluteCanvasSize.Y)
			end
		end
	end

	notify('chatlogs enabled')
end)

cmd_library.add({'clearchatlogs', 'clearcl', 'ccl'}, 'clears the chatlogs', function(vstorage)
	local existing_log = z.core_gui:FindFirstChild('chat_logs')

	if existing_log then
		for _,log in existing_log.main_container.chatlogs:GetChildren() do
			if log:IsA('TextLabel') then
				pcall(z.destroy, log)
			end
		end
		return notify('chatlogs cleared')
	end

	notify('chatlogs not enabled')
end)

cmd_library.add({'instakillreach', 'instksreach'}, '[reach: number] - always applies newest damage inflicted 50 times and adds reach', function(vstorage, reach)
	local reach_size = tonumber(reach) or 40

	local tool = z.local_player.Character:FindFirstChildOfClass('Tool') or z.local_player.Backpack:FindFirstChildOfClass('Tool')
	if not tool then return notify('equip a tool and maybe then we\'ll see') end

	notify('enabled instakillreach')

	maid.add('instks_sword_activated', tool.Activated, function()
		for _, v in pairs(workspace:GetDescendants()) do
			if v.Name == 'HumanoidRootPart' and v.Parent:FindFirstChildOfClass('Humanoid') or v.Name == 'Head' and v.Parent:FindFirstChildOfClass('Humanoid') then
				if (tool.Handle.Position-v.Position).Magnitude <= reach_size then
					for i = 1, 50 do
						firetouchinterest(v, tool.Handle, 0)
						firetouchinterest(v, tool.Handle, 1)
						task.wait()
					end
				end
			end
		end
	end)
end)

cmd_library.add({'grabtp'}, '[name: string] - only works on ink game, you also need takedown ability', function(vstorage, name)
	local targets = get_plr(name)
	if not targets then
		return notify(`player '{name and tostring(name) or ''}' does not exist`)
	end

	for _, target in pairs(targets) do
		notify(`bringing {target.Name} to you`)
		local old_pos = z.local_character:GetPivot()
		local takedown = z.local_player.Backpack:FindFirstChild('Takedown') or z.local_character:FindFirstChild('Takedown')
		local local_humanoid = z.local_character:WaitForChild('Humanoid')
		local target_character = target.Character
		local target_humanoid = target_character:WaitForChild('Humanoid')

		if takedown.Parent ~= z.local_character then
			local_humanoid:EquipTool(takedown)
		end

		if target_humanoid.MoveDirection ~= Vector3.zero then
			z.local_character:PivotTo(predict_movement(target, 20))
		else
			z.local_character:PivotTo(target_character.HumanoidRootPart.CFrame*CFrame.new(0, 0, 3))
		end

		task.wait(1)

		local_humanoid:UnequipTools()
		z.local_character:PivotTo(old_pos)
	end
end)

cmd_library.add({'speed','walkspeed','ws'}, '[speed: number] - sets your walkspeed to [NUM], set num as blank to be default speed', function(vstorage, speed)
	if tonumber(speed) then
		notify(`speed set to {tonumber(speed)}`)
	else
		notify('invalid speed, speed set to default')
	end

	hypernull(function()
		z.local_character:WaitForChild('Humanoid').WalkSpeed = tonumber(speed) or z.default_walkspeed
	end)
end)

cmd_library.add({'jump','jumppower','jp'}, '[power: number] - sets your jumppower to [NUM], set num as blank to be default jumppower', function(vstorage, power)
	if tonumber(power) then
		notify(`jumppower set to {tonumber(power)}`)
	else
		notify('invalid jumppower, jumppower set to default')
	end

	local hum = z.local_character:WaitForChild('Humanoid')
	hypernull(function()
		hum.UseJumpPower = true
		hum.JumpPower = tonumber(power) or z.default_jumppower
	end)
end)

cmd_library.add({'saveposition', 'savepos'}, 'save a position to load with loadpos', function(vstorage)
	vstorage.pos = z.local_character:GetPivot()
	local pos = vstorage.pos.Position
	notify(`saved position: x:{math.floor(pos.X)}, y:{math.floor(pos.Y)}, z:{math.floor(pos.Z)}`)
end)

cmd_library.add({'loadposition', 'loadpos'}, 'load the position saved with savepos', function()
	local vstorage = cmd_library.get_variable_storage('savepos')
	if vstorage.pos then
		hypernull(function()
			z.local_character:PivotTo(vstorage.pos)
		end)
		notify('loaded position')
	else
		notify('you haven\'t saved a position using saveposition')
	end
end)

cmd_library.add({'unloopjumppower', 'unloopjp'}, 'disables loopjumppower', function()
	local vstorage = cmd_library.get_variable_storage('loopjp')

	if vstorage.enabled then
		maid.remove('loopjp')
		notify('disabled loopjumppower')
		z.local_character:FindFirstChildOfClass('Humanoid').JumpPower = vstorage.old_power or z.default_jumppower
	else
		notify('loopjumppower is already disabled!')
	end
end)

cmd_library.add({'loopjumppower', 'loopjp'}, '[power: number] - sets your jumppower to specified number in a loop', function(vstorage, power)
	power = tonumber(power) or 32

	notify(`setting jumppower to {power} in a loop`)
	vstorage.enabled = true
	vstorage.old_power = z.local_character:FindFirstChildOfClass('Humanoid').JumpPower

	maid.add('loopjp', z.run_service.Heartbeat, function()
		pcall(function()
			local hum = z.local_character:WaitForChild('Humanoid')
			hum.UseJumpPower = true
			hum.JumpPower = power
		end)
	end)
end)

cmd_library.add({'unloopwalkspeed', 'unloopws'}, 'disables loopwalkspeed', function()
	local vstorage = cmd_library.get_variable_storage('loopws')

	if vstorage.enabled then
		maid.remove('loopws')
		notify('disabled loopwalkspeed')
		z.local_character:FindFirstChildOfClass('Humanoid').WalkSpeed = vstorage.old_speed or z.default_walkspeed
	else
		notify('loopwalkspeed is already disabled!')
	end
end)

cmd_library.add({'loopwalkspeed', 'loopws'}, '[speed: number] - sets your walkspeed to specified number in a loop', function(vstorage, speed)
	speed = tonumber(speed) or 32

	notify(`setting walkspeed to {speed} in a loop`)
	vstorage.enabled = true
	vstorage.old_speed = z.local_character:FindFirstChildOfClass('Humanoid').WalkSpeed

	maid.add('loopws', z.run_service.Heartbeat, function()
		pcall(function()
			z.local_character:FindFirstChildOfClass('Humanoid').WalkSpeed = speed
		end)
	end)
end)

cmd_library.add({'commandswitching','cmdswitching','cmdswitch'},'[allow: boolean] - allow command switching (if mobile fly turns to mobilefly)',function(vstorage,arg)
	local valuething = false
	if arg:lower() == 'true' then
		valuething = true
	end
	z.allow_command_switching = valuething
	notify('commandswitching set to '..tostring(valuething))
end)

cmd_library.add({'unfly', 'disablefly', 'stopfly'}, 'disable flight', function()
	if z.is_mobile and z.allow_command_switching then
		cmd_library.execute('unmobilefly')
		return
	end
	local vstorage = cmd_library.get_variable_storage('fly')

	if vstorage.enabled then
		notify('disabled flight')
		maid.remove('flight')
		vstorage.enabled = false
		vstorage.part:Destroy()
	else
		notify('flight is already disabled!')
	end
end)

cmd_library.add({'fly', 'cframefly'}, '[flyspeed: number] - enable flight', function(vstorage, speed)
	if z.is_mobile and z.allow_command_switching then
		cmd_library.execute('mobilefly',speed)
		return
	end
	if vstorage.enabled then
		return notify('already flying')
	end
	vstorage.enabled = true
	speed = tonumber(speed) or 1
	notify(`enabled flight{speed ~= 1 and ` with speed {speed}` or ''}`)

	local flight_part = Instance.new('Part', workspace)
	vstorage.part = flight_part

	flight_part.CFrame = z.local_character:GetPivot()
	flight_part.Anchored = true
	flight_part.Transparency = 1
	flight_part.CanCollide = false

	maid.add('flight', z.run_service.Heartbeat, function()
		pcall(function()
			local old_pos = flight_part.Position
			flight_part.CFrame = CFrame.lookAt(old_pos, workspace.CurrentCamera.CFrame * CFrame.new(0, 0, -250).Position)
			z.local_character:FindFirstChildOfClass('Humanoid'):ChangeState(Enum.HumanoidStateType.Running)
			z.local_character:PivotTo(flight_part.CFrame)
			z.local_character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero

			if z.user_input_service:GetFocusedTextBox() == nil then else return end
			local direction = Vector3.new(0,0,0)
			if z.user_input_service:IsKeyDown(Enum.KeyCode.W) then
				direction += Vector3.new(0,0,-1)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.A) then
				direction += Vector3.new(-1,0,0)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.S) then
				direction += Vector3.new(0,0,1)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.D) then
				direction += Vector3.new(1,0,0)
			end
			local offset = Vector3.new(
				direction.X * speed,
				direction.Y * speed,
				direction.Z * speed
			)

			flight_part.CFrame *= CFrame.new(offset)
		end)
	end)
end)

cmd_library.add({'mobilefly', 'mobilecframefly', 'mobilecffly'}, '[flyspeed: number] - mobile fly', function(vstorage, flyspeed)
	if vstorage.enabled then
		return notify('mobile fly already enabled')
	end

	vstorage.enabled = true
	flyspeed = tonumber(flyspeed) or 1
	notify(`enabled mobile flight{flyspeed ~= 1 and ` with speed {flyspeed}` or ''}`)

	pcall(function()
		maid.remove('mobile_flight')
	end)

	local flight_part = Instance.new('Part', workspace)
	vstorage.part = flight_part
	flight_part.CFrame = z.local_character:GetPivot()
	flight_part.Anchored = true
	flight_part.Transparency = 1
	flight_part.CanCollide = false

	local control_module = require(z.local_player.PlayerScripts:WaitForChild('PlayerModule'):WaitForChild('ControlModule'))

	maid.add('mobile_flight', z.run_service.Heartbeat, function()
		pcall(function()
			local old_pos = flight_part.Position
			flight_part.CFrame = CFrame.lookAt(old_pos, workspace.CurrentCamera.CFrame * CFrame.new(0, 0, -250).Position)

			z.local_character:PivotTo(flight_part.CFrame)
			z.local_character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero

			local direction = control_module:GetMoveVector()
			local offset = Vector3.new(
				direction.X * flyspeed,
				direction.Y * flyspeed,
				direction.Z * flyspeed
			)

			flight_part.CFrame *= CFrame.new(offset)
		end)
	end)
end)

cmd_library.add({'unmobilefly', 'unmobilecframefly', 'unmobilecffly'}, 'disable mobile fly', function()
	local vstorage = cmd_library.get_variable_storage('mobilefly')

	if not vstorage.enabled then
		return notify('mobile fly not enabled')
	end

	vstorage.enabled = false
	notify('disabled mobile flight')
	maid.remove('mobile_flight')

	if vstorage.part then
		pcall(z.destroy, vstorage.part)
		vstorage.part = nil
	end
end)

cmd_library.add({'cleanconnections', 'clean'},'Cleans the connection handler\'s connections',function()
	maid.clean()
end)

cmd_library.add({'bfly', 'bypassfly'}, 'bypass flight', function(vstorage,speed)
	if vstorage.enabled then
		return notify('bypass flight already enabled')
	end

	vstorage.enabled = true
	if tonumber(speed) then
		vstorage.speed = tonumber(speed)
	else
		vstorage.speed = 1
	end
	notify('bypass flight enabled, when you disable bfly you will teleport to the part')

	local cam = workspace.CurrentCamera
	vstorage.old_subject = cam.CameraSubject
	vstorage.old_speed = z.local_character:FindFirstChildOfClass('Humanoid').WalkSpeed
	local flight_part = Instance.new('Part', workspace)
	vstorage.part = flight_part
	vstorage.old_parent = z.local_character.Parent
	z.local_character.Parent = nil
	flight_part.CFrame = z.local_character:GetPivot()
	flight_part.Anchored = true
	flight_part.Transparency = 0.5
	flight_part.CanCollide = false
	workspace.CurrentCamera.CameraSubject = flight_part
	local control_module
	--pcall(function()
	--	control_module = require(z.local_player.PlayerScripts:WaitForChild('PlayerModule',1):WaitForChild('ControlModule',1))
	--end)
	maid.add('bypassfly_connection', z.run_service.Heartbeat, function()
		xpcall(function()
			local old_pos = flight_part.Position
			flight_part.CFrame = CFrame.lookAt(old_pos, workspace.CurrentCamera.CFrame * CFrame.new(0, 0, -250).Position)
			z.local_character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
			z.local_character:FindFirstChildOfClass('Humanoid'):ChangeState(Enum.HumanoidStateType.Running)

			--local s,e = pcall(function() if control_module:GetMoveVector() == Vector3.zero then end end) 
			--if s == false then
			if z.user_input_service:GetFocusedTextBox() == nil then else return end
			local direction = Vector3.new(0,0,0)
			if z.user_input_service:IsKeyDown(Enum.KeyCode.W) then
				direction += Vector3.new(0,0,-1)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.A) then
				direction += Vector3.new(-1,0,0)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.S) then
				direction += Vector3.new(0,0,1)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.D) then
				direction += Vector3.new(1,0,0)
			end
			local offset = Vector3.new(
				direction.X * vstorage.speed,
				direction.Y * vstorage.speed,
				direction.Z * vstorage.speed
			)

			flight_part.CFrame *= CFrame.new(offset)
			--else
			--	local direction = control_module:GetMoveVector()
			--	local offset = Vector3.new(
			--		direction.X * vstorage.speed,
			--		direction.Y * vstorage.speed,
			--		direction.Z * vstorage.speed
			--	)

			--	flight_part.CFrame *= CFrame.new(offset)
			--end
		end,warn)
	end)
end)

cmd_library.add({'unbfly', 'disablebfly', 'stopbfly'}, 'disable bypass flight', function()
	local vstorage = cmd_library.get_variable_storage('bfly')

	if vstorage.enabled then
		notify('disabled bypass flight')
		maid.remove('bypassfly_connection')
		vstorage.enabled = false

		if vstorage.part then
			maid.add('anti_anti_teleport_connection_for_fly', z.run_service.Heartbeat, function()
				z.local_character.Parent = vstorage.old_parent
				z.local_character:PivotTo(vstorage.part.CFrame)
			end)
			task.delay(0.5, function()
				maid.remove('anti_anti_teleport_connection_for_fly')
				pcall(function() vstorage.part:Destroy() end)
			end)
		end

		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
		z.local_character:FindFirstChildOfClass('Humanoid').WalkSpeed = vstorage.old_speed or z.default_walkspeed
		workspace.CurrentCamera.CameraSubject = vstorage.old_subject or z.local_character:FindFirstChildOfClass('Humanoid')
	else
		notify('bypass flight is already disabled')
	end
end)

cmd_library.add({'respawnpoint', 'illusion', 'rp'}, 'makes your respawnpoint be the place where you died', function()
	notify('enabled illusion')
	local has_died = false
	local death_pos

	maid.add('resetspawn', z.run_service.Heartbeat, function() -- will overwrite if already exists
		pcall(function()
			local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
			if not humanoid then return end

			local health = humanoid.Health

			if not has_died and health <= 0 then
				has_died = true
				death_pos = z.local_character:GetPivot()
			elseif has_died and health > 0 then
				hypernull(function()
					z.local_character:PivotTo(death_pos)
				end)
				maid.remove('resetspawn')
				if health > 1 then
					has_died = false
				end
			end
		end)
	end)
end)

cmd_library.add({'unfakelag', 'undesync'}, 'disables fake lag', function()
	cmd_library.get_variable_storage('fakelag').enabled = false
	notify('disabled fakelag')
end)

cmd_library.add({'fakelag', 'desync'}, 'creates fake lag applied on your character', function(vstorage)
	if vstorage.enabled then return notify('fakelag is already enabled') end
	vstorage.enabled = true
	notify('enabled fakelag')

	while vstorage.enabled do
		pcall(function()
			local anchor_part = z.local_character:FindFirstChild('UpperTorso') and z.local_character.HumanoidRootPart or z.local_character.Torso
			anchor_part.Anchored = true

			local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
			for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
				track:AdjustSpeed(track.Speed * 1.1)
			end

			humanoid.Jump = true
		end)

		task.wait(.1)

		pcall(function()
			local anchor_part = z.local_character:FindFirstChild('UpperTorso') and z.local_character.HumanoidRootPart or z.local_character.Torso
			anchor_part.Anchored = false

			for _, track in pairs(z.local_character:FindFirstChildOfClass('Humanoid'):GetPlayingAnimationTracks()) do
				track:AdjustSpeed(track.Speed * 1.05)
			end
		end)

		task.wait(.1)
	end
end)

cmd_library.add({'antifling', 'afling', 'antif'}, 'stops other exploiters from flinging you (except from partfling)', function(vstorage)

	if vstorage.enabled == nil then
		vstorage.enabled = false
	end

	if not vstorage.enabled then
		vstorage.enabled = true
		notify('antifling enabled')

		maid.add('antifling', z.run_service.Heartbeat, function()
			local other_players = z.players:GetPlayers()
			table.remove(other_players, table.find(other_players, z.local_player))

			for _, v in pairs(other_players) do
				if v.Character then
					for _, part in pairs(v.Character:GetDescendants()) do
						if part:IsA('BasePart') then
							part.AssemblyAngularVelocity = Vector3.zero
						end
					end
				end
			end
		end)
	else
		notify('antifling is already enabled')
	end
end)

cmd_library.add({'unantifling', 'unafling', 'unantif'}, 'disables antifling', function()
	local vstorage = cmd_library.get_variable_storage('antifling')

	if vstorage.enabled then
		vstorage.enabled = false
		notify('disabled antifling')
		maid.remove('antifling')
	else
		notify('antifling is already disabled')
	end
end)

cmd_library.add({'gettools','tools'}, 'attempts to steal tools from others', function()
	local count = 0

	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA('Tool') or v:IsA('BackpackItem') or v:IsA('HopperBin') then
			count += 1
			v.Parent = z.local_player.Backpack
		end
	end

	notify('stole '..count..' tools')
end)

cmd_library.add({'fullbright', 'fb'}, 'overrides lighting properties', function()
	hypernull(function()
		z.lighting.Brightness = 10
		z.lighting.ClockTime = 14.5
		z.lighting.FogEnd = 10000
		z.lighting.GlobalShadows = true
		z.lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
	end)

	notify('lighting properties set')
end)

cmd_library.add({'partcontrol', 'pcontrol'}, 'networkownership goes brr', function()
	notify('fetching all parts, your character will be reset')

	local camera = workspace.CurrentCamera
	local old_cframe = z.local_character.HumanoidRootPart.CFrame

	z.local_character:FindFirstChildOfClass('Humanoid'):ChangeState(15)
	z.local_player.SimulationRadius = 1000

	wait(z.players.RespawnTime + .5)

	z.local_player.SimulationRadius = 1000
	z.local_character:WaitForChild('HumanoidRootPart').CFrame = old_cframe
	workspace.CurrentCamera = camera

	task.wait(.8)

	local found_part
	for _, part in ipairs(workspace:GetDescendants()) do
		pcall(function()
			if not part.Anchored and #part:GetConnectedParts() <= 1 and network_check(part) then
				found_part = part
			end
		end)
	end

	if not found_part then
		notify('no controllable parts were found')
		return
	end

	z.local_character:WaitForChild('Animate'):Destroy()

	found_part.CFrame = z.local_character:GetPivot()
	notify('found controllable part')

	--local control_module = require(z.local_player.PlayerScripts:WaitForChild('PlayerModule'):WaitForChild('ControlModule'))
	local velocity_fling = Vector3.new(0,500*5,0)
	local velocity_offset = Vector3.new(14.46262424,14.46262424,14.46262424)

	task.spawn(function()
		while task.wait(3) do
			found_part.Velocity = velocity_offset + Vector3.new(0, math.cos(tick() * 10) / 100, 0)
			z.local_character:PivotTo(found_part.CFrame)
			camera.CameraSubject = z.local_character:FindFirstChildOfClass('Humanoid')
		end
	end)

	maid.add('partcontrol', z.run_service.Heartbeat, function()
		pcall(function()
			workspace.Gravity = 0
			workspace.FallenPartsDestroyHeight = -9999999
			found_part.CanCollide = false
			found_part.Velocity = Vector3.zero

			local old_pos = found_part.Position
			found_part.CFrame = CFrame.lookAt(old_pos, camera.CFrame * CFrame.new(0, 0, -250).Position)

			if not network_check(found_part) then
				found_part.Velocity = velocity_offset
				z.local_character:PivotTo(found_part.CFrame)
				camera.CameraSubject = z.local_character:FindFirstChildOfClass('Humanoid')
				return
			end

			local in_attack = false
			for _, plr in ipairs(z.players:GetPlayers()) do
				if plr ~= z.local_player and plr.Character and plr.Character:FindFirstChild('Head') then
					local part = Instance.new('Part', workspace)
					part.Anchored = true
					part.Size = Vector3.new(plr.SimulationRadius, plr.SimulationRadius, plr.SimulationRadius)
					part.Color = Color3.new(1, 0, 0)
					part.Transparency = 1
					part.CanCollide = false
					part.CastShadow = false
					part.CFrame = plr.Character:GetPivot()
					z.debris:AddItem(part, 0.1)

					if (z.local_character.Head.Position - plr.Character.Head.Position).Magnitude <= 18 then
						in_attack = true
					end

					local part2 = Instance.new('Part', workspace)
					part2.Anchored = true
					part2.Size = Vector3.new(27, 27, 27)
					part2.Color = Color3.new(0, 0, 1)
					part2.Transparency = 1
					part2.CanCollide = false
					part2.CastShadow = false
					part2.CFrame = plr.Character:GetPivot()
					z.debris:AddItem(part2, 0.05)
				end
			end

			camera.CameraSubject = found_part
			z.local_character:PivotTo(CFrame.new(found_part.Position.X, found_part.Position.Y + (in_attack and 0 or -12), found_part.Position.Z))

			if not network_check(found_part) then
				notify('could not reposition part cframe: partcontrol cancelled')
				maid.remove('partcontrol')
				return
			end

			if z.user_input_service:GetFocusedTextBox() == nil then else return end
			local direction = Vector3.new(0,0,0)
			if z.user_input_service:IsKeyDown(Enum.KeyCode.W) then
				direction += Vector3.new(0,0,-1)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.A) then
				direction += Vector3.new(-1,0,0)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.S) then
				direction += Vector3.new(0,0,1)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.D) then
				direction += Vector3.new(1,0,0)
			end
			local offset = Vector3.new(
				direction.X * 1,
				direction.Y * 1,
				direction.Z * 1
			)

			found_part.CFrame *= CFrame.new(offset)
		end)
	end)
end)

cmd_library.add({'help', 'cmds', 'commands'}, 'shows you this menu', function(vstorage)
	commands_gui.Enabled = true
	if not vstorage.loaded_commands then
		vstorage.loaded_commands = true
		for _, v in pairs(cmd_library._commands) do
			local newframe = command_template:Clone()
			newframe.Visible = true
			newframe.Parent = commands_gui.main_container.commands
			newframe.TextWrapped = true
			newframe.AutomaticSize = Enum.AutomaticSize.Y
			if #v['names'] == 1 then
				newframe.Text = v.names[1]..': '..v.description
			else
				local finishednames = v['names'][1]
				for inow, ve in ipairs(v['names']) do
					if inow == 1 then
						continue
					end
					finishednames ..= ', '..ve
				end
				newframe.Text = finishednames..': '..v.description
			end
		end
	end
end)

cmd_library.add({'unairwalk','unairw','unfloat'},'turns off airwalk', function()
	local vstorage = cmd_library.get_variable_storage('airwalk')
	if vstorage.air_walk_part then
		vstorage.enabled = false
		pcall(function()
			z.destroy(vstorage.air_walk_part)
			vstorage.air_walk_part = nil
		end)

		maid.remove('air_walk')
		notify('disabled airwalk')
	else
		notify('airwalk is already disabled')
	end
end)

cmd_library.add({'airwalk', 'airw','float'}, 'turns on airwalk', function(vstorage)
	if vstorage.enabled then
		return notify('airwalk already enabled')
	end

	vstorage.enabled = true
	notify('enabled airwalk')

	local air_walk_part = Instance.new('Part', workspace)
	air_walk_part.Size = Vector3.new(7, 2, 3)
	air_walk_part.Transparency = 1
	air_walk_part.Anchored = true
	air_walk_part.CanCollide = true
	air_walk_part.Name = tostring(z.http:GenerateGUID())
	vstorage.air_walk_part = air_walk_part

	maid.add('air_walk', z.run_service.Heartbeat, function()
		if vstorage.enabled and air_walk_part and air_walk_part.Parent then
			pcall(function()
				air_walk_part.CFrame = z.local_character.HumanoidRootPart.CFrame + Vector3.new(0, -4, 0)
			end)
		else
			maid.remove('air_walk')
			z.destroy(air_walk_part)
			vstorage.air_walk_part = nil
			vstorage.enabled = false
		end
	end)
end)

cmd_library.add({'visible','uninvis','uninvisible'}, 'makes your character visible', function()
	local vstorage = cmd_library.get_variable_storage('invisible')

	if vstorage.used == false then
		notify('you aren\'t invisible')
	else
		notify('became visible')
		vstorage.used = false

		local pos = z.local_character.HumanoidRootPart.CFrame
		local camera = workspace.CurrentCamera

		z.local_character:FindFirstChildOfClass('Humanoid'):ChangeState(15)
		z.local_player.SimulationRadius = 1000
		wait(z.players.RespawnTime + 0.5)
		z.local_player.SimulationRadius = 1000
		z.local_character:WaitForChild('HumanoidRootPart').CFrame = pos

		workspace.CurrentCamera = camera
	end
end)

cmd_library.add({'invisible', 'invis'}, 'makes your character invisible for others', function(vstorage)
	if vstorage.used then
		notify('you already are invisible')
	else
		notify('you are now invisible')
		vstorage.used = true
		task.spawn(function()
			local position = z.local_character.HumanoidRootPart.Position
			task.wait(.1)
			z.local_character:MoveTo(position + Vector3.new(0, 1000000, 0))
			task.wait(.1)
			local hrpc = z.local_character.HumanoidRootPart:Clone()
			task.wait(.1)
			local hrp = z.local_character.HumanoidRootPart
			pcall(z.destroy, hrp)
			hrpc.Parent = z.local_character
			task.delay(.2, function()
				z.local_character:MoveTo(position)
			end)
		end)
	end
end)

cmd_library.add({'seatbring', 'sbring'}, '[player: string] - bring a player using a seat tool', function(_, name)
	local targets = get_plr(name)
	if not targets then
		return notify(`player '{name and tostring(name) or ''}' does not exist`)
	end

	for _, target in pairs(targets) do
		local tool = z.local_character:FindFirstChildOfClass('Tool')

		if not tool then
			notify('equip a tool and maybe then we\'ll see')
			repeat task.wait() until z.local_character:FindFirstChildOfClass('Tool')
			tool = z.local_character:FindFirstChildOfClass('Tool')
		end

		local seat = tool:FindFirstChildWhichIsA('Seat', true)
		if not seat then
			return notify('tool does not have a seat')
		end

		notify(`bringing {target.Name} to you`)

		local old_pos = z.local_character:GetPivot()
		local start_time = tick()
		local target_char = target.Character
		if not target_char then continue end

		local target_hrp = target_char:FindFirstChild('HumanoidRootPart')
		local target_humanoid = target_char:FindFirstChildOfClass('Humanoid')
		if not target_hrp or not target_humanoid then continue end

		repeat
			local predicted_pos = predict_movement(target, 9)
			if not predicted_pos then break end

			firetouchinterest(seat, target_hrp, 0)
			firetouchinterest(seat, target_hrp, 1)
			z.local_character:PivotTo(predicted_pos * CFrame.new(-4, 0, 3))
			z.run_service.Heartbeat:Wait()

			firetouchinterest(seat, target_hrp, 0)
			firetouchinterest(seat, target_hrp, 1)
			z.local_character:PivotTo(predicted_pos * CFrame.new(4, 0, 3))
			z.run_service.Heartbeat:Wait()
			z.run_service.Heartbeat:Wait()
		until tick() - start_time >= 4 or (seat and seat:FindFirstChild('SeatWeld')) or target_humanoid.Sit

		z.local_character:PivotTo(old_pos)
	end
end)

cmd_library.add({'to', 'goto'}, '[player: string] - teleport infront of the target', function(_, name)
	local targets = get_plr(name)
	if not targets then
		return notify(`player '{name and tostring(name) or ''}' does not exist`) 
	end

	for _, target in pairs(targets) do
		if not target.Character:FindFirstChild('HumanoidRootPart') then
			notify(`player {target.Name} does not have a rootpart | skipping`)
			continue
		end

		hypernull(function()
			z.local_character:PivotTo(target.Character:FindFirstChild('HumanoidRootPart').CFrame*CFrame.new(0,3,-3))
		end)
	end
end)

cmd_library.add({'test'}, 'test the status of the notification system', function()
	for i = 1,20 do
		notify('notification system working')
		task.wait(.1)
	end
end)

cmd_library.add({'fling'}, '[player: string] - uses velocity to fling people', function(_, name)
	local targets = get_plr(name)
	if not targets then
		return notify(`player '{name and tostring(name) or ''}' does not exist`)
	end

	for _, target in targets do
		task.wait(.3)

		notify(`now flinging {target.Name}`)

		local hrp = z.local_character:FindFirstChild('HumanoidRootPart')
		local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
		local motor = hrp:FindFirstChildOfClass('Motor6D')
		local target_char = target.Character
		local target_hrp = target_char.HumanoidRootPart
		local target_humanoid = target_char:FindFirstChildOfClass('Humanoid')
		local cam = workspace.CurrentCamera

		local old_pos = hrp.CFrame
		local max_vel = Vector3.new(2500,2500,2500)
		local zero_vel = Vector3.zero
		local oldtick = tick()
		maid.add("velfling_connection",z.run_service.Heartbeat,function()
			if target_hrp.Velocity.Magnitude < 100 and tick()-oldtick < 5 then
				hrp.CFrame = predict_movement(game:GetService("Players"):GetPlayerFromCharacter(target_char),((target_humanoid.WalkSpeed*68.75)/100))
				hrp.Velocity = max_vel
			else
				hrp.Velocity = zero_vel
				z.local_character:PivotTo(old_pos)
				maid.remove("velfling_connection")
			end
		end)
	end
end)

cmd_library.add({'respawn', 'reset', 'die'}, 'reset your character yes', function()
	notify('respawning your character')

	z.local_character:BreakJoints()
	z.local_character.Humanoid.Health = 0
end)

cmd_library.add({'gravity'}, '[gravity: number] - sets workspace gravity value to [gravity]', function(_, gravity)
	gravity = tonumber(gravity) or 196.2
	notify(`gravity set to {gravity}`)
	workspace.Gravity = gravity
end)

cmd_library.add({'unantisit','unantis','unasit'}, 'enables sitting', function()
	notify('anti-sit disabled')

	z.local_character.Humanoid:SetStateEnabled('Seated', true)
	z.local_character.Humanoid.Sit = false
end)

cmd_library.add({'antisit', 'antis', 'asit'}, 'disables sitting', function()
	notify('antisit enabled')

	z.local_character.Humanoid:SetStateEnabled('Seated', false)
	z.local_character.Humanoid.Sit = true
end)

cmd_library.add({'unwalkfling','unwalkf'}, 'disables walkfling', function()
	local vstorage = cmd_library.get_variable_storage('walkf')
	vstorage.enabled = false
	notify('walkfling disabled')
end)

cmd_library.add({'walkfling', 'walkf'}, 'enables walkfling, credits to X', function(vstorage)
	if vstorage.enabled then
		return notify('walkfling is already enabled')
	else
		notify('walkfling enabled')
	end

	if vstorage.alreadyused then
		vstorage.enabled = true
	else
		vstorage.alreadyused = true
		vstorage.enabled = true

		local hrp, c, vel, movel = nil, nil, nil, 0.1

		while z.run_service.Heartbeat:Wait() do
			if vstorage.enabled then
				while vstorage.enabled and not (c and c.Parent and hrp and hrp.Parent) do
					z.run_service.Heartbeat:Wait()
					c = z.local_character
					hrp = c:FindFirstChild('HumanoidRootPart') or c:FindFirstChild('Torso') or c:FindFirstChild('UpperTorso')
				end

				if vstorage.enabled then
					vel = hrp.Velocity

					hrp.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)

					z.run_service.RenderStepped:Wait()

					if c and c.Parent and hrp and hrp.Parent then
						hrp.Velocity = vel
					end

					z.run_service.Stepped:Wait()

					if c and c.Parent and hrp and hrp.Parent then
						hrp.Velocity = vel + Vector3.new(0, movel, 0)
						movel = movel * -1
					end
				end
			end
		end
	end
end)

cmd_library.add({'follow', 'chase'}, '[player: string] - lock onto another player instantly', function(vstorage, name)
	local targets = get_plr(name)
	local target = targets[1]

	if not target or not target.Character or not target.Character:FindFirstChild('HumanoidRootPart') then
		notify('target not found, idiotzoid.')
		return
	end

	if vstorage.target then
		return notify(`already following {vstorage.target.Name}, use 'unfollow' first`)
	end

	vstorage.target = target
	local hrp = z.local_character:WaitForChild('HumanoidRootPart')

	maid.add('follow_connection', z.run_service.RenderStepped, function()
		if not vstorage.target or not vstorage.target.Character or not vstorage.target.Character:FindFirstChild('HumanoidRootPart') then
			return
		end

		local target_hrp = vstorage.target.Character.HumanoidRootPart
		hrp.CFrame = target_hrp.CFrame
		hrp.Velocity = Vector3.zero
		hrp.RotVelocity = Vector3.zero
	end)

	notify(`now following {target.Name}`)
end)

cmd_library.add({'unfollow','stopfollow'}, 'stop following', function()
	local vstorage = cmd_library.get_variable_storage('follow')
	if vstorage.target then
		maid.remove('follow_connection')
		notify('stopped following '.. (vstorage.target and vstorage.target.Name or 'the player'))
		vstorage.target = nil
	else
		notify('you are not following anyone')
	end
end)

cmd_library.add({'view','spectate'}, '[player: string] - spectate another player', function(vstorage, name)
	local targets = get_plr(name)
	local target = targets[1]

	if not target or not target.Character or not target.Character:FindFirstChild('Humanoid') then
		return notify('target not found, idiotzoid')
	end

	local camera = workspace.CurrentCamera
	camera.CameraSubject = target.Character:FindFirstChild('Humanoid')
	vstorage.target = target

	notify(`spectating {target.Name}`)
end)

cmd_library.add({'unview', 'unspectate', 'endview'}, 'stop spectating', function()
	local vstorage = cmd_library.get_variable_storage('view')
	if vstorage.target then
		local camera = workspace.CurrentCamera
		camera.CameraSubject = z.local_character:FindFirstChild('Humanoid')
		notify(`stopped spectating {vstorage.target.Name}`)
		vstorage.target = nil
	else
		notify('you aren\'t viewing anyone, noob')
	end
end)


cmd_library.add({'noclip'}, 'walk through stuff', function(vstorage)
	if vstorage.enabled then
		return notify('noclip already enabled')
	end

	vstorage.enabled = true
	notify('noclip enabled')

	maid.add('noclip_connection', z.run_service.Stepped, function()
		if z.local_character then
			for _, part in pairs(z.local_character:GetDescendants()) do
				if part:IsA('BasePart') then
					part.CanCollide = false
				end
			end
		end
	end)
end)

z.sim_range_reset = false
cmd_library.add({'reloadnetwork','reloadnet','rnetwork','rnet'}, 'resets your simulationradius to 1000 and forces partfling to stop', function(vstorage)
	notify('fetching all parts, your character will be reset')
	pcall(function()
		maid.remove('part_trap_follow')
	end)
	task.spawn(function()
		z.sim_range_reset = true
		local old_pos = z.local_character:GetPivot()
		local success = false

		pcall(function()
			z.local_player.SimulationRadius = 1000
			z.local_character:BreakJoints()
			success = true
		end)
		task.wait(.01)
		task.wait(z.players.RespawnTime + .5)
		z.local_character:PivotTo(old_pos)
		task.wait(1)
		z.sim_range_reset = false
	end)
end)

cmd_library.add({'partfling', 'pf', 'partf'}, '[player: string, velocity: number] - flings someone using parts, far more undetectable and works in collisions off.', function(_, name, vel)
	local velocity = tonumber(vel) or 2500

	local function part_fling(target)
		if not target then return end

		if target == z.local_player then
			notify('cannot partfling yourself')
			return
		end

		local part = get_closest_part()

		if part == nil then 
			notify('there is nothing to partfling with') 
			return 
		end

		if part:IsDescendantOf(z.local_character) then
			notify('cannot use your own character parts for partfling')
			return
		end

		local old_cframe_part = part.CFrame
		local old_cf = z.local_character:GetPivot()
		local old_pos = part.Position
		local old_anchored = part.Anchored
		local old_can_collide = part.CanCollide
		local start_tick = tick()

		repeat
			z.local_character:PivotTo(part.CFrame)
			z.run_service.RenderStepped:Wait()
		until network_check(part) == true or z.sim_range_reset == true or tick() - start_tick >= 5

		if network_check(part) == true then
			notify(`successfully gained part ownership and used partfling on {target.Name} with velocity {velocity}`)
		else
			if z.sim_range_reset == false then
				notify('attempt to gain ownership timed out, consider using reloadnetwork')
				z.local_character:PivotTo(old_cf)
				return
			end
		end

		z.local_character:PivotTo(old_cf)
		z.local_character:FindFirstChildOfClass('Humanoid'):ChangeState(Enum.HumanoidStateType.Running)

		local target_hrp = target.Character and target.Character:FindFirstChild('HumanoidRootPart')
		if not target_hrp then 
			notify(`target {target.Name} has no HumanoidRootPart`)
			return 
		end

		local target_original_pos = target_hrp.Position
		local fling_start_tick = tick()

		part.Anchored = false
		part.CanCollide = false

		part.AssemblyLinearVelocity = Vector3.new(0, velocity * 2, 0)

		local fling_detected = false
		local max_distance_reached = 0
		local lost_ownership_tick = nil

		local function cleanup_part()
			pcall(function()
				part.Anchored = old_anchored
				part.CanCollide = old_can_collide
				part.AssemblyLinearVelocity = Vector3.zero
				part.Position = old_pos
				part.CFrame = old_cframe_part
			end)
		end
		pcall(function()
			maid.remove('partfling_connection')
		end)
		maid.add('partfling_connection', z.run_service.Heartbeat, function()
			if not target_hrp or not target_hrp.Parent then
				maid.remove('partfling_connection')
				cleanup_part()
				notify(`target {target.Name} no longer exists`)
				return
			end

			local time_elapsed = tick() - fling_start_tick
			local distance_from_original = (target_hrp.Position - target_original_pos).Magnitude
			max_distance_reached = math.max(max_distance_reached, distance_from_original)

			if distance_from_original >= 100 and time_elapsed <= 1 then
				fling_detected = true
				maid.remove('partfling_connection')
				cleanup_part()
				notify(`successfully flung {target.Name} (distance: {math.floor(distance_from_original)} studs in {math.floor(time_elapsed * 100) / 100}s)`)
				return
			end

			if fling_detected then
				maid.remove('partfling_connection')
				cleanup_part()
				return
			end

			if time_elapsed >= 10 then
				maid.remove('partfling_connection')
				cleanup_part()
				if max_distance_reached >= 100 then
					notify(`successfully flung {target.Name} (max distance: {math.floor(max_distance_reached)} studs)`)
				else
					notify(`partfling on {target.Name} timed out (max distance: {math.floor(max_distance_reached)} studs)`)
				end
				return
			end

			if network_check(part) ~= true then
				if lost_ownership_tick == nil then
					lost_ownership_tick = tick()
					cleanup_part()
				end

				local time_since_lost = tick() - lost_ownership_tick

				if time_since_lost >= 1 then
					maid.remove('partfling_connection')

					if max_distance_reached >= 100 then
						notify(`successfully flung {target.Name} (distance: {math.floor(max_distance_reached)} studs, lost ownership)`)
					else
						notify(`lost ownership of part while flinging {target.Name} (only moved {math.floor(max_distance_reached)} studs)`)
					end
				end
				return
			end

			z.local_player.SimulationRadius = 1000
			part.Anchored = false
			part.CanCollide = false
			part.AssemblyLinearVelocity = Vector3.new(0, velocity, 0)
			part.CFrame = target_hrp.CFrame
		end)
	end

	local targets = get_plr(name)
	if not targets then
		return notify(`player {name and tostring(name) or ''} doesn't exist`)
	end

	for _, target in pairs(targets) do
		part_fling(target)
		task.wait(0.5)
	end
end)

cmd_library.add({'parttrap', 'ptrap', 'trap'}, '[player: string] - trap them in a cage like a monkey', function(vstorage, name)
	local targets = get_plr(name)
	if not targets then
		return notify(`player {name and tostring(name) or ''} doesn't exist`)
	end

	local function get_closest_part_e(excluded)
		local best_part = nil
		local smallest_magnitude = nil

		for _, v in ipairs(workspace:GetDescendants()) do
			if v:IsA('BasePart') and v.Anchored == false and not v.Parent:FindFirstChildOfClass('Humanoid') and not v.Parent.Parent:FindFirstChildOfClass('Humanoid') and not v:IsDescendantOf(z.local_character) then
				if smallest_magnitude == nil or (z.local_character.Head.Position - v.Position).Magnitude < smallest_magnitude then
					if #v:GetConnectedParts() < 2 and not table.find(excluded, v) then
						smallest_magnitude = (z.local_character.Head.Position - v.Position).Magnitude
						best_part = v
					end
				end
			end
		end

		return best_part
	end

	local function part_trap(target, number, excluded)
		if not target or not target.Character then return end

		local part = get_closest_part_e(excluded)

		if part == nil then 
			if number == 1 then
				notify('there is nothing to parttrap with')
			end
			return 
		end

		local old_cframe_part = part.CFrame
		local old_cf = z.local_character:GetPivot()

		local start_tick = tick()
		repeat
			z.local_character:PivotTo(part.CFrame)
			z.run_service.RenderStepped:Wait()
		until network_check(part) == true or z.sim_range_reset == true or tick() - start_tick >= 5

		if network_check(part) ~= true then
			if z.sim_range_reset == false then
				if number == 1 then
					notify('attempt to gain ownership timed out, consider using reloadnetwork')
				end
				z.local_character:PivotTo(old_cf)
				return
			end
		end

		z.local_character:PivotTo(old_cf)
		z.local_character:FindFirstChildOfClass('Humanoid'):ChangeState(Enum.HumanoidStateType.Running)

		local weld_part1 = target.Character:FindFirstChild('Head')
		if number >= 2 and number ~= 6 then
			if target.Character:FindFirstChild('Torso') then
				weld_part1 = target.Character.Torso
			else
				weld_part1 = target.Character:FindFirstChild('HumanoidRootPart')
			end
		end

		if not weld_part1 then return end

		local part_test = Instance.new('Part', workspace)
		part_test.Anchored = true
		part_test.Size = weld_part1.Size
		part_test.CFrame = weld_part1.CFrame
		part_test.Orientation = Vector3.new(0, 90, 0)
		part_test.Transparency = 1
		part_test.CanCollide = false

		local allowed = true
		local old_part_cframe = nil
		local recursion_done = false

		maid.add(`part_trap_connection_{number}`, z.run_service.Heartbeat, function()
			if not target or not target.Character or not target.Character:IsDescendantOf(game) or not target.Character:FindFirstChild('Humanoid') or target.Character.Humanoid.Health <= 1 or z.sim_range_reset == true then
				maid.remove('part_trap_follow')
				maid.remove(`part_trap_connection_{number}`)
				pcall(function() part_test:Destroy() end)
				maid.add(`removing_trap_connection_{number}`, z.run_service.Heartbeat, function()
					part.CanCollide = true
				end)
				task.delay(1, function()
					maid.remove(`removing_trap_connection_{number}`)
				end)
				return
			end

			z.local_player.SimulationRadius = 1000

			local move_magnitude = target.Character.Humanoid.MoveDirection.Magnitude

			if move_magnitude > 0.1 and allowed == true then
				if number == 1 then
					part.CFrame = part_test.CFrame * CFrame.new(0, 15, 0)
				elseif number == 2 then
					part.CFrame = part_test.CFrame * CFrame.new(0, 15, -1.5)
				elseif number == 3 then
					part.CFrame = part_test.CFrame * CFrame.new(0, 15, 1.5)
				elseif number == 4 then
					part.CFrame = part_test.CFrame * CFrame.new(-1.5, 15, 0)
				elseif number == 5 then
					part.CFrame = part_test.CFrame * CFrame.new(1.5, 15, 0)
				elseif number >= 6 then
					part.CFrame = part_test.CFrame * CFrame.new(0, 15, 0)
				end
			else
				if allowed == true then
					part.Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424) + Vector3.new(0, math.cos(tick() * 10) / 100, 0)

					if number == 1 then
						part.CFrame = part_test.CFrame * CFrame.new(0, 2, 0)
						part.Orientation = Vector3.new(0, 0, 0)
					elseif number == 2 then
						part.CFrame = part_test.CFrame * CFrame.new(0, 0.75, -1.75)
						part.Orientation = Vector3.new(90, 90, 0)
					elseif number == 3 then
						part.CFrame = part_test.CFrame * CFrame.new(0, 0.5, 1.75)
						part.Orientation = Vector3.new(90, 90, 0)
					elseif number == 4 then
						part.CFrame = part_test.CFrame * CFrame.new(-2, 0.75, 0)
						part.Orientation = Vector3.new(90, 0, 0)
					elseif number == 5 then
						part.CFrame = part_test.CFrame * CFrame.new(1.95, 0.75, 0)
						part.Orientation = Vector3.new(90, 0, 0)
					elseif number == 6 then
						part.CFrame = part_test.CFrame * CFrame.new(0, 2, 0)
						part.Orientation = Vector3.new(0, 90, 0)
					elseif number == 7 then
						part.CFrame = part_test.CFrame * CFrame.new(0, -2, 0)
						part.Orientation = Vector3.new(0, 90, 0)
					elseif number == 8 then
						part.CFrame = part_test.CFrame * CFrame.new(0, -2, 0)
						part.Orientation = Vector3.new(0, 0, 0)
					end

					old_part_cframe = part.CFrame

					if not recursion_done and number < 8 then
						recursion_done = true
						table.insert(excluded, part)
						part_trap(target, number + 1, excluded)
					end

					allowed = false
				else
					part.CFrame = old_part_cframe
					part.Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424) + Vector3.new(0, math.cos(tick() * 10) / 100, 0)
					part.CanCollide = false
				end
			end

			if part_test and weld_part1 then
				pcall(function()
					part_test.CFrame = weld_part1.CFrame
				end)
			end
		end)
	end

	for _, target in pairs(targets) do
		notify(`attempted trap on {target.Name}`)
		part_trap(target, 1, {})
		task.wait(0.5)
	end
end)

cmd_library.add({'infjump', 'infinitejump'}, 'infinite jump', function()
	notify('enabled infinite jump')

	local cooldown = false
	pcall(function()
		maid.remove('infinite_jump')
	end)
	maid.add('infinite_jump', z.user_input_service.JumpRequest, function()
		if cooldown == true then return end
		local hum = z.local_character:WaitForChild('Humanoid')
		cooldown = true

		task.delay(0,function()
			cooldown = false
		end)

		if hum.FloorMaterial == Enum.Material.Air then
			hum:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end)
end)

cmd_library.add({'uninfjump', 'uninfinitejump'}, 'infinite unjump', function()
	notify('disabled infinite jump')
	maid.remove('infinite_jump')
end)

cmd_library.add({'clip'}, 'stop walking through stuff', function()
	local vstorage = cmd_library.get_variable_storage('noclip')

	if not vstorage.enabled then
		return notify('noclip is not enabled')
	end

	vstorage.enabled = false
	maid.remove('noclip_connection')
	notify('disabled noclip')

	for _, v in pairs(z.local_character:GetChildren()) do
		if v:IsA('BasePart') then
			v.CanCollide = true
		end
	end

	if z.local_character and z.local_character:FindFirstChild('HumanoidRootPart') then
		z.local_character.HumanoidRootPart.CFrame += Vector3.new(0, 3, 0)
	end
end)

cmd_library.add({'unantivoid','unantiv'},'disables anti void',function()
	maid.remove('anti_void_connection')
	notify('disabled antivoid')
end)

cmd_library.add({'antivoid','antiv'},'stops the void from killing you.',function()
	notify('enabled antivoid')
	pcall(function()
		maid.remove('anti_void_connection')
	end)
	maid.add('anti_void_connection',game:GetService('RunService').Heartbeat,function()
		if z.local_character:GetPivot().Position.Y <= workspace.FallenPartsDestroyHeight+30 then
			for _, v in ipairs(z.local_character:GetChildren()) do
				pcall(function()
					v.Velocity = Vector3.new(0,0,0)
					v.AssemblyLinearVelocity = Vector3.new(0,0,0)
				end)
			end
			z.local_character:PivotTo(z.local_character:GetPivot()*CFrame.new(0,(workspace.FallenPartsDestroyHeight*-1)+50,0))
		end
	end)
end)

cmd_library.add({'revive'}, 'attempts to stop oneshots', function(vstorage)
	if vstorage.enabled then
		return notify('revive already enabled')
	end

	notify('activated revive')
	vstorage.enabled = true

	local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
	local old_health = humanoid.Health

	local invalid_states = {
		[Enum.HumanoidStateType.FallingDown] = true,
		[Enum.HumanoidStateType.Swimming] = true,
		[Enum.HumanoidStateType.Seated] = true,
		[Enum.HumanoidStateType.Jumping] = true,
		[Enum.HumanoidStateType.Freefall] = true
	}

	maid.add('revive_state', z.run_service.Heartbeat, function()
		if not vstorage.enabled then
			maid.remove('revive_state')
			return
		end
		pcall(function()
			if not invalid_states[humanoid:GetState()] then
				humanoid:ChangeState(Enum.HumanoidStateType.Running)
			end
		end)
	end)

	maid.add('revive_health_update', z.run_service.Heartbeat, function()
		if vstorage.enabled and humanoid.Health > 0 then
			old_health = humanoid.Health
		end
	end)

	humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	humanoid.RequiresNeck = false
	humanoid.BreakJointsOnDeath = false

	maid.add('revive', humanoid:GetPropertyChangedSignal('Health'), function()
		if not vstorage.enabled then
			maid.remove('revive')
			return
		end

		local current_health = humanoid.Health
		humanoid:ChangeState(Enum.HumanoidStateType.Running)

		if old_health > current_health then
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
			humanoid.Parent = z.replicated_storage
			z.replicated_storage:FindFirstChild('Humanoid').Parent = z.local_character

			if current_health <= 5 then
				vstorage.enabled = false
				maid.remove('revive')
				maid.remove('revive_state')
				maid.remove('revive_health_update')
			end
		else
			old_health = current_health
		end
	end)
end)

cmd_library.add({'thirdp', '3rdp', 'thirdperson'}, 'forces your camera to be third person', function()
	notify('now third-person')

	z.local_player.CameraMaxZoomDistance = 128
	z.local_player.CameraMode = 'Classic'
end)

cmd_library.add({'swim', 'swimmode'}, '[speed: number] - swim in the air', function(vstorage, speed)
	speed = tonumber(speed) or z.default_walkspeed
	if vstorage.enabled then
		return notify('swim is already enabled')
	end
	vstorage.enabled = true

	notify('enabled swim')

	local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
	workspace.Gravity /= 10

	local states = {
		Enum.HumanoidStateType.Climbing, Enum.HumanoidStateType.FallingDown,
		Enum.HumanoidStateType.Flying, Enum.HumanoidStateType.Freefall,
		Enum.HumanoidStateType.GettingUp, Enum.HumanoidStateType.Jumping,
		Enum.HumanoidStateType.Landed, Enum.HumanoidStateType.Physics,
		Enum.HumanoidStateType.PlatformStanding, Enum.HumanoidStateType.Ragdoll,
		Enum.HumanoidStateType.Running, Enum.HumanoidStateType.RunningNoPhysics,
		Enum.HumanoidStateType.Seated, Enum.HumanoidStateType.StrafingNoPhysics,
		Enum.HumanoidStateType.Swimming
	}

	for _, state in pairs(states) do
		humanoid:SetStateEnabled(state, false)
	end

	humanoid:ChangeState(Enum.HumanoidStateType.Swimming)

	vstorage.old_speed = humanoid.WalkSpeed
	humanoid.WalkSpeed = speed
end)

cmd_library.add({'unswim', 'unswimmode', 'stopswim'}, 'stop swimming in the air', function()
	local vstorage = cmd_library.get_variable_storage('swim')
	if not vstorage.enabled then
		return notify('swim is already disabled')
	end

	notify('disabled swim')

	local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
	workspace.Gravity *= 10

	local states = {
		Enum.HumanoidStateType.Climbing, Enum.HumanoidStateType.FallingDown,
		Enum.HumanoidStateType.Flying, Enum.HumanoidStateType.Freefall,
		Enum.HumanoidStateType.GettingUp, Enum.HumanoidStateType.Jumping,
		Enum.HumanoidStateType.Landed, Enum.HumanoidStateType.Physics,
		Enum.HumanoidStateType.PlatformStanding, Enum.HumanoidStateType.Ragdoll,
		Enum.HumanoidStateType.Running, Enum.HumanoidStateType.RunningNoPhysics,
		Enum.HumanoidStateType.Seated, Enum.HumanoidStateType.StrafingNoPhysics,
		Enum.HumanoidStateType.Swimming
	}

	for _, state in pairs(states) do
		humanoid:SetStateEnabled(state, true)
	end

	humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)

	if tonumber(vstorage.old_speed) then
		humanoid.WalkSpeed = vstorage.old_speed or z.default_walkspeed
	end
end)

cmd_library.add({'disabletouchevent', 'disablete'}, 'disables the touched event of all parts using it', function()
	notify('succesfully eradicated touched event')
	pcall(function()
		maid.remove('disable_touch_event')
	end)
	maid.add('disable_touch_event', z.run_service.Heartbeat, function()
		local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')

		if humanoid.Health < 1 then
			maid.remove('disable_touch_event')
			for _, v in ipairs(workspace:GetDescendants()) do
				pcall(function() v.CanTouch = true end)
			end
			return
		end
	end)

	for _, v in ipairs(workspace:GetDescendants()) do
		pcall(function() v.CanTouch = false end)
	end
end)


cmd_library.add({'partwalkfling', 'pwalkfling', 'partwalkf', 'pwalkf', 'pwf'}, '[player: string, torso_mode: boolean] - partfling on walkfling ', function(_, name, torso_mode)
	local targets = get_plr(name)
	if not targets then 
		return notify(`player '{name and tostring(name) or ''}' does not exist`)
	end

	notify('fetching all parts, your character will be reset')

	for _, target in pairs(targets) do
		local old_cframe = z.local_character.HumanoidRootPart.CFrame
		local cam = workspace.CurrentCamera

		z.local_character:FindFirstChildOfClass('Humanoid'):ChangeState(15)
		z.local_player.SimulationRadius = 1000
		task.wait(z.players.RespawnTime + 0.5)

		if not target.Character or not target.Character:FindFirstChild('HumanoidRootPart') then
			notify(`{target.Name} has no character`)
			continue
		end

		local target_hrp = target.Character.HumanoidRootPart
		z.local_player.SimulationRadius = 1000
		z.local_character:WaitForChild('HumanoidRootPart').CFrame = old_cframe
		workspace.CurrentCamera = cam
		task.wait(0.2)

		local parts = {}
		local cycle_duration = 3
		local distance = 18
		local cycle_progress = 0

		local is_player_part = function(part)
			for _, plr in ipairs(z.players:GetPlayers()) do
				if plr.Character and plr.Character:IsAncestorOf(part) then
					return true
				end
			end
			return false
		end

		local is_valid_part = function(part)
			if part.Anchored or is_player_part(part) or part:IsDescendantOf(z.local_character) then
				return false
			end
			if part.Parent ~= workspace and (part.Parent:FindFirstChildOfClass('Humanoid') or part.Parent.Parent and part.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				return false
			end
			return #part:GetConnectedParts() < 2
		end

		for _, part in ipairs(workspace:GetDescendants()) do
			if part:IsA('BasePart') and is_valid_part(part) then
				table.insert(parts, part)
			end
		end

		local desc_added_conn = workspace.DescendantAdded:Connect(function(part)
			if part:IsA('BasePart') and is_valid_part(part) then
				table.insert(parts, part)
			end
		end)

		task.wait(1)

		maid.add('part_walkfling_'..target.Name, z.run_service.Heartbeat, function(dt)
			if not target.Character or not target_hrp:IsDescendantOf(workspace) or not target:IsDescendantOf(game) then
				maid.remove('part_walkfling_'..target.Name)
				desc_added_conn:Disconnect()
				return
			end

			for i = #parts, 1, -1 do
				local part = parts[i]

				if not part:IsDescendantOf(game) then
					table.remove(parts, i)
					continue
				end

				pcall(function()
					if part.ReceiveAge ~= 0 or part.Anchored then return end

					part.CanCollide = false
					part.Velocity = Vector3.new(0, 500000000000, 0)

					if torso_mode ~= 'true' then
						cycle_progress = (cycle_progress + dt / cycle_duration) % 1
						local alpha = 2 * math.pi * cycle_progress
						part.CFrame = CFrame.Angles(0, alpha, 0) * CFrame.new(0, 0, distance + part.Size.Magnitude) + target_hrp.Position
					else
						if target == z.local_player then
							part.CFrame = target_hrp.CFrame
						else
							local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
							if humanoid then
								humanoid:SetStateEnabled('Seated', false)
								humanoid.Sit = true
							end
							local offset_cframe = target_hrp.CFrame * CFrame.new(0, 0, -(17 + part.Size.Magnitude))
							part.CFrame = offset_cframe
							z.local_character:PivotTo(offset_cframe)
						end
					end
				end)
			end
		end)
	end
end)

cmd_library.add({'countcommands', 'countcmds'}, 'counts the commands very useful yes', function()
	notify(#cmd_library._commands .. ' commands')
end)

cmd_library.add({'remotespy', 'rspy', 'octospy'}, 'allows you to spy on remotes', function()
	notify('loading remote spy')
	local success, err = pcall(function()
		loadstring(game:HttpGet('https://raw.githubusercontent.com/InfernusScripts/Octo-Spy/refs/heads/main/Main.lua'))()
	end)
	if not success then
		notify('failed to load remotespy: ' .. tostring(err))
	end
end)

cmd_library.add({'dex'}, 'dex explorer (dex++)', function()
	notify('loading dex')
	local success, err = pcall(function()
		loadstring(game:HttpGet('https://gist.githubusercontent.com/BROgenesis/958c1fee7d8ad100da7f7d020d5d67f3/raw/8dc95caca1b46aa9f4d9dd2433f6be3d9bc69e45/Dex++'))()
	end)
	if not success then
		notify('failed to load dex: ' .. tostring(err))
	end
end)

cmd_library.add({'robang', 'bang'}, '[player: string] - robang someone', function(vstorage, target)
	local target_plr = get_plr(target)
	if not target_plr or #target_plr == 0 then
		return notify(`player '{target and tostring(target) or ''}' doesn't exist`)
	end
	target_plr = target_plr[1]

	if not target_plr.Character or not target_plr.Character:FindFirstChild('Head') then
		return notify(`{target_plr.Name} does not have a character or head`)
	end

	notify(`banging {target_plr.Name}`)

	maid.add('ro_bang_connection', z.run_service.Stepped, function()
		pcall(function()
			if not target_plr.Character or not target_plr.Character:FindFirstChild('Head') then
				maid.remove('ro_bang_connection')
				return
			end

			local cf = CFrame.new(0, 1.5, -1.5 - math.sin(os.clock() * 15)) * CFrame.Angles(0, math.rad(180), 0)
			local hrp = z.local_character and z.local_character:FindFirstChild('HumanoidRootPart')
			if hrp then
				hrp.Velocity = Vector3.zero
				hrp.RotVelocity = Vector3.zero
				z.local_character:PivotTo(target_plr.Character.Head.CFrame * cf)
			end
		end)
	end)
end)

cmd_library.add({'stoprobang', 'unbang', 'endbang'}, 'stop robang', function()
	notify('stopped robang')
	maid.remove('ro_bang_connection')
end)

cmd_library.add({'sit', 'togglesit'}, 'buckle up', function()
	local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
	if humanoid then
		humanoid.Sit = not humanoid.Sit
		notify('set sitting to ' .. tostring(humanoid.Sit))
	end
end)

cmd_library.add({'freeze'}, 'freezes your character in place', function()
	notify('you are now frozen')

	maid.add('freeze_connection', z.run_service.Heartbeat, function()
		pcall(function()
			z.local_character.HumanoidRootPart.Anchored = true
		end)
	end)
end)

cmd_library.add({'unfreeze', 'thaw'}, 'unfreezes your character', function()
	notify('you are now unfrozen')
	maid.remove('freeze_connection')

	pcall(function()
		z.local_character.HumanoidRootPart.Anchored = false
	end)
end)

cmd_library.add({'spin', 'spinbot'}, '[speed: number] - spins your character', function(vstorage, speed)
	if vstorage.enabled then
		return notify('spin is already enabled')
	end

	speed = tonumber(speed) or 20
	vstorage.enabled = true
	notify(`spinning at speed {speed}`)

	local spin_part = Instance.new('BodyAngularVelocity')
	spin_part.Name = 'spin_velocity'
	hypernull(function()
		spin_part.Parent = z.local_character.HumanoidRootPart
	end)
	hypernull(function()
		spin_part.MaxTorque = Vector3.new(0, math.huge, 0)
		spin_part.AngularVelocity = Vector3.new(0, speed, 0)
	end)

	vstorage.spin_part = spin_part
end)


cmd_library.add({'unspin', 'unspinbot'}, 'stops spinning your character', function()
	local vstorage = cmd_library.get_variable_storage('spin')

	if vstorage.enabled then
		notify('stopped spinning')
		vstorage.enabled = false

		if vstorage.spin_part then
			pcall(z.destroy, vstorage.spin_part)
		end
	else
		notify('spin is not enabled')
	end
end)

cmd_library.add({'day'}, 'sets time to day', function()
	notify('time set to day')
	z.lighting.ClockTime = 14
end)

cmd_library.add({'night'}, 'sets time to night', function()
	notify('time set to night')
	z.lighting.ClockTime = 0
end)

cmd_library.add({'time'}, '[time: number] - sets the time of day', function(_, time)
	time = tonumber(time) or 14
	notify(`time set to {time}`)
	z.lighting.ClockTime = time
end)

cmd_library.add({'fogend', 'fog'}, '[distance: number] - sets fog end distance', function(_, distance)
	if tonumber(distance) then
		distance = tonumber(distance)
	else
		distance = 100000
	end
	notify(`fog end set to {distance}`)
	z.lighting.FogEnd = distance
end)

cmd_library.add({'brightness'}, '[value: number] - sets brightness', function(_, value)
	value = tonumber(value) or 2
	notify(`brightness set to {value}`)
	z.lighting.Brightness = value
end)

cmd_library.add({'hitbox', 'torsosize'}, '[size: number] - makes rootpart hitbox bigger', function(_, size)
	size = tonumber(size) or 10
	notify(`hitbox size set to {size}`)
	pcall(function()
		maid.remove('hitbox_connection')
	end)
	maid.add('hitbox_connection', z.run_service.Heartbeat, function()
		for _, plr in pairs(z.players:GetPlayers()) do
			if plr ~= z.local_player and plr.Character then
				local head = plr.Character:FindFirstChild('HumanoidRootPart')
				if head then
					head.Size = Vector3.new(size, size, size)
					head.Transparency = 0.75
					head.BrickColor = BrickColor.random()
					head.CanCollide = false
				end
			end
		end
	end)
end)

cmd_library.add({'unhitbox', 'untorsosize'}, 'resets rootpart hitbox', function()
	notify('hitbox reset')
	maid.remove('hitbox_connection')

	for _, plr in pairs(z.players:GetPlayers()) do
		if plr.Character and plr ~= z.local_player then
			local head = plr.Character:FindFirstChild('HumanoidRootPart')
			if head then
				head.Size = Vector3.new(2, 1, 1)
				head.Transparency = 1
			end
		end
	end
end)

cmd_library.add({'orbit'}, '[player: string, distance: number, speed: number] - orbit around a player', function(vstorage, name, distance, speed)
	local targets = get_plr(name)
	if not targets then
		return notify(`player '{name and tostring(name) or ''}' does not exist`)
	end

	local target = targets[1]
	if vstorage.target then
		return notify(`already orbiting {vstorage.target.Name}, use unorbit first`)
	end

	vstorage.target = target
	vstorage.distance = tonumber(distance) or 10
	vstorage.speed = tonumber(speed) or 2
	vstorage.angle = 0

	notify(`now orbiting {target.Name}`)

	maid.add('orbit_connection', z.run_service.Heartbeat, function(dt)
		pcall(function()
			if vstorage.target and vstorage.target.Character and vstorage.target.Character:FindFirstChild('HumanoidRootPart') then
				vstorage.angle = (vstorage.angle + dt * vstorage.speed) % (2 * math.pi)
				local offset = CFrame.Angles(0, vstorage.angle, 0) * CFrame.new(0, 0, vstorage.distance)
				z.local_character:PivotTo(vstorage.target.Character.HumanoidRootPart.CFrame * offset)
			end
		end)
	end)
end)

cmd_library.add({'unorbit'}, 'stop orbiting', function()
	local vstorage = cmd_library.get_variable_storage('orbit')

	if vstorage.target then
		notify(`stopped orbiting {vstorage.target.Name}`)
		vstorage.target = nil
		maid.remove('orbit_connection')
	else
		notify('you are not orbiting anyone')
	end
end)

cmd_library.add({'serverhop', 'shop'}, 'hops to a different server', function()
	notify('attempting to server hop')

	local success, servers = pcall(function()
		return z.http:JSONDecode(game:HttpGet(`https://games.roproxy.com/v1/games/{game.PlaceId}/servers/Public?sortOrder=Asc&limit=100`))
	end)

	if success and servers and servers.data then
		for _, server in pairs(servers.data) do
			if server.id ~= game.JobId and server.playing < server.maxPlayers then
				z.teleport_service:TeleportToPlaceInstance(game.PlaceId, server.id, z.local_player)
				return
			end
		end
	end

	notify('could not find a different server')
end)

cmd_library.add({'platformstand', 'pstand'}, 'enables platform stand', function()
	notify('platform stand enabled')
	z.local_character:FindFirstChildOfClass('Humanoid').PlatformStand = true
end)

cmd_library.add({'unplatformstand', 'unpstand'}, 'disables platform stand', function()
	notify('platform stand disabled')
	z.local_character:FindFirstChildOfClass('Humanoid').PlatformStand = false
end)

cmd_library.add({'enablecoreuis','showguis','enableuis'},'enables the coreguis',function()
	notify('enabled every coregui')
	game:GetService('StarterGui'):SetCoreGuiEnabled(Enum.CoreGuiType.All,true)
end)

cmd_library.add({'droptools', 'dtools'}, 'drops all tools', function()
	notify('tools dropped')

	pcall(function()
		for _, tool in pairs(z.local_player.Backpack:GetChildren()) do
			tool.Parent =  z.local_player.Character
		end
		task.delay(0.15,function()
			for _, tool in pairs(z.local_character:GetChildren()) do
				if tool:IsA('Tool') then
					tool.CanBeDropped = true
					tool.Parent = workspace
				end
			end
			task.delay(0.05,function()
				z.local_character:FindFirstChildOfClass('Humanoid'):UnequipTools()
			end)
		end)
	end)
end)

cmd_library.add({'equiptools', 'etools'}, 'equips all tools', function()
	notify('tools equipped')

	pcall(function()
		for _, tool in pairs(z.local_player.Backpack:GetChildren()) do
			if tool:IsA('Tool') or tool:IsA('HopperBin') or tool:IsA('BackpackItem') then
				tool.Parent = z.local_character
			end
		end
	end)
end)

cmd_library.add({'unequiptools', 'utools'}, 'unequips all tools', function()
	notify('tools unequipped')
	z.local_character.Humanoid:UnequipTools()
end)

cmd_library.add({'animation', 'anim'}, '[id: number] - plays an animation by id', function(_, id)
	if not id then
		return notify('provide an animation id')
	end

	notify(`playing animation {id}`)

	local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
	local animator = humanoid:FindFirstChildOfClass('Animator')

	if not animator then
		animator = Instance.new('Animator')
		animator.Parent = humanoid
	end

	local animation = Instance.new('Animation')
	animation.AnimationId = `rbxassetid://{id}`

	local track = animator:LoadAnimation(animation)
	track:Play()
end)

cmd_library.add({'stopanimations', 'stopanim'}, 'stops all playing animations', function()
	notify('animations stopped')

	local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
	for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
		track:Stop()
	end
end)

cmd_library.add({'age', 'accountage'}, '[player: string] - shows account age', function(_, name)
	local targets = get_plr(name) or {z.local_player}
	if not targets then
		return notify(`player {name and tostring(name) or ''} doesn't exist`)
	end

	for _, target in pairs(targets) do
		local days = target.AccountAge
		local creation_date = os.date('*t', os.time() - (days * 86400))

		notify(`{target.Name}'s account age: {math.floor(days / 365)} year(s), {math.floor((days % 365) / 30)} month(s), {(days % 365) % 30} day(s)\n created on: {creation_date.month}/{creation_date.day}/{creation_date.year} (month/day/year)`)
	end
end)

cmd_library.add({'placeid', 'pid'}, 'shows place id', function()
	notify(`place id: {game.PlaceId}`)
end)

cmd_library.add({'jobid', 'jid'}, 'shows job id', function()
	notify(`job id: {game.JobId}`)
end)

cmd_library.add({'fps'}, 'shows current fps', function()
	local fps = math.floor(1 / z.run_service.Heartbeat:Wait())
	notify(`fps: {fps}`)
end)

cmd_library.add({'ping'}, 'shows your ping', function()
	local ping = z.local_player:GetNetworkPing() * 1000
	notify(`ping: {math.floor(ping)}ms`)
end)

cmd_library.add({'antiafk', 'noafk'}, 'prevents afk kick', function()
	notify('anti-afk enabled')

	local vu = game:GetService('VirtualUser')
	pcall(function()
		maid.remove('anti_afk')
	end)
	maid.add('anti_afk', z.local_player.Idled, function()
		vu:CaptureController()
		vu:ClickButton2(Vector2.new())
	end)
end)

cmd_library.add({'unantiafk', 'unnoafk'}, 'disables anti-afk', function()
	notify('anti-afk disabled')
	maid.remove('anti_afk')
end)

cmd_library.add({'freecam', 'fcam'}, '[speed: number] - detach camera from character', function(vstorage,speed)
	if vstorage.enabled then
		return notify('freecam already enabled')
	end

	vstorage.enabled = true
	if tonumber(speed) then
		vstorage.speed = tonumber(speed)
	else
		vstorage.speed = 1
	end
	notify('freecam enabled')

	local cam = workspace.CurrentCamera
	vstorage.old_subject = cam.CameraSubject
	vstorage.old_parent = z.local_character.Parent
	vstorage.old_speed = z.local_character:FindFirstChildOfClass('Humanoid').WalkSpeed
	local flight_part = Instance.new('Part', workspace)
	vstorage.part = flight_part
	z.local_character:FindFirstChildOfClass('Humanoid').WalkSpeed = 0
	flight_part.CFrame = z.local_character:GetPivot()
	flight_part.Anchored = true
	flight_part.Transparency = 1
	flight_part.CanCollide = false
	workspace.CurrentCamera.CameraSubject = flight_part
	z.local_character.Parent = nil
	local control_module = require(z.local_player.PlayerScripts:WaitForChild('PlayerModule'):WaitForChild('ControlModule'))
	maid.add('freecam', z.run_service.Heartbeat, function()
		pcall(function()
			local old_pos = flight_part.Position
			flight_part.CFrame = CFrame.lookAt(old_pos, workspace.CurrentCamera.CFrame * CFrame.new(0, 0, -250).Position)
			z.local_character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero

			if z.user_input_service:GetFocusedTextBox() == nil then else return end
			local direction = Vector3.new(0,0,0)
			if z.user_input_service:IsKeyDown(Enum.KeyCode.W) then
				direction += Vector3.new(0,0,-1)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.A) then
				direction += Vector3.new(-1,0,0)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.S) then
				direction += Vector3.new(0,0,1)
			end
			if z.user_input_service:IsKeyDown(Enum.KeyCode.D) then
				direction += Vector3.new(1,0,0)
			end
			local offset = Vector3.new(
				direction.X * vstorage.speed,
				direction.Y * vstorage.speed,
				direction.Z * vstorage.speed
			)

			flight_part.CFrame *= CFrame.new(offset)
		end)
	end)
end)

cmd_library.add({'unfreecam', 'unfcam'}, 'reattach camera to character', function()
	local vstorage = cmd_library.get_variable_storage('freecam')

	if not vstorage.enabled then
		return notify('freecam not enabled')
	end
	vstorage.enabled = false
	notify('freecam disabled')

	maid.remove('freecam')
	z.local_character.Parent = vstorage.old_parent
	workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	z.local_character:FindFirstChildOfClass('Humanoid').WalkSpeed = vstorage.old_speed or z.default_walkspeed
	workspace.CurrentCamera.CameraSubject = vstorage.old_subject or z.local_character:FindFirstChildOfClass('Humanoid')
end)

cmd_library.add({'fov'}, '[fov: number] - sets field of view', function(_, value)
	value = tonumber(value) or 70
	notify(`fov set to {value}`)
	workspace.CurrentCamera.FieldOfView = value
end)

cmd_library.add({'hipheight', 'hheight'}, '[height: number] - sets hip height', function(_, height)
	height = tonumber(height) or 0
	notify(`hip height set to {height}`)
	z.local_character:FindFirstChildOfClass('Humanoid').HipHeight = height
end)

cmd_library.add({'loophipheight', 'loophheight'}, '[height: number] - loops hip height', function(vstorage, height)
	height = tonumber(height) or 5
	notify(`looping hip height at {height}`)
	pcall(function()
		maid.remove('loop_hip_height')
	end)
	maid.add('loop_hip_height', z.run_service.Heartbeat, function()
		pcall(function()
			z.local_character:FindFirstChildOfClass('Humanoid').HipHeight = height
		end)
	end)
end)

cmd_library.add({'unloophipheight', 'unloophheight'}, 'stops looping hip height', function()
	notify('stopped looping hip height')
	maid.remove('loop_hip_height')
end)

cmd_library.add({'tpwalk', 'teleportwalk'}, '[multiplier: number] - teleport when walking', function(vstorage, multiplier)
	if vstorage.enabled then
		return notify('tpwalk already enabled')
	end

	vstorage.enabled = true
	vstorage.multiplier = tonumber(multiplier) or 3
	vstorage.last_tp = 0
	vstorage.next_delay = math.random(10, 100) / 1000
	notify(`tpwalk enabled with multiplier {vstorage.multiplier}`)

	pcall(function()
		maid.remove('tpwalk')
	end)

	maid.add('tpwalk', z.run_service.Heartbeat, function()
		pcall(function()
			local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
			if humanoid.MoveDirection.Magnitude > 0 then
				local current_time = os.clock()

				if current_time - vstorage.last_tp >= vstorage.next_delay then
					z.local_character:TranslateBy(humanoid.MoveDirection * vstorage.multiplier)
					vstorage.last_tp = current_time
					vstorage.next_delay = math.random(10, 80) / 1000
				end
			end
		end)
	end)
end)

cmd_library.add({'untpwalk', 'unteleportwalk'}, 'disables tpwalk', function()
	local vstorage = cmd_library.get_variable_storage('tpwalk')

	if not vstorage.enabled then
		return notify('tpwalk not enabled')
	end

	vstorage.enabled = false
	notify('tpwalk disabled')
	maid.remove('tpwalk')
end)

cmd_library.add({'maxzoom'}, '[distance: number] - sets max camera zoom distance', function(_, distance)
	distance = tonumber(distance) or 128
	notify(`max zoom set to {distance}`)
	z.local_player.CameraMaxZoomDistance = distance
end)

cmd_library.add({'minzoom'}, '[distance: number] - sets min camera zoom distance', function(_, distance)
	distance = tonumber(distance) or 0.5
	notify(`min zoom set to {distance}`)
	z.local_player.CameraMinZoomDistance = distance
end)

cmd_library.add({'fixcam', 'resetcam'}, 'resets camera properties', function()
	notify('camera reset')

	local cam = workspace.CurrentCamera
	cam.CameraType = Enum.CameraType.Custom
	cam.CameraSubject = z.local_character:FindFirstChildOfClass('Humanoid')
	cam.FieldOfView = 70
	z.local_player.CameraMaxZoomDistance = 128
	z.local_player.CameraMinZoomDistance = 0.5
end)

cmd_library.add({'deleteplayer', 'delplayer'}, '[player: string] - deletes a player\'s character client sided', function(_, name)
	local targets = get_plr(name)
	if not targets then
		return notify(`player '{name and tostring(name) or ''}' does not exist`)
	end

	for _, target in pairs(targets) do
		if target.Character then
			z.destroy(target.Character)
			notify(`deleted {target.Name}`)
		end
	end
end)

cmd_library.add({'kick'}, '[player: string] - kicks a player on client side', function(_, name)
	local targets = get_plr(name)
	if not targets then
		return notify(`player '{name and tostring(name) or ''}' does not exist`)
	end

	for _, target in pairs(targets) do
		pcall(function()
			target.Parent = nil
		end)
		notify(`kicked {target.Name}`)
	end
end)

cmd_library.add({'skydive'}, '[height: number] - launches you into the sky', function(_, height)
	height = tonumber(height) or 500
	notify(`launching {height} studs up`)

	local hrp = z.local_character:FindFirstChild('HumanoidRootPart')
	if hrp then
		hrp.CFrame += Vector3.new(0, height, 0)
	end
end)

cmd_library.add({'removesky'}, 'removes sky', function()
	notify('sky removed')

	for _, v in pairs(z.lighting:GetChildren()) do
		if v:IsA('Sky') then
			z.destroy(v)
		end
	end
end)

cmd_library.add({'ambient'}, '[color: hex] - sets ambient lighting', function(_, color)
	local parsed = parse_hex(color) or Color3.fromRGB(255, 255, 255)
	notify('ambient set')
	z.lighting.Ambient = parsed
end)

cmd_library.add({'outdoorambient'}, '[color: hex] - sets outdoor ambient', function(_, color)
	local parsed = parse_hex(color) or Color3.fromRGB(255, 255, 255)
	notify('outdoor ambient set')
	z.lighting.OutdoorAmbient = parsed
end)

cmd_library.add({'colorshift'}, '[top: hex, bottom: hex] - sets color shift', function(_, top, bottom)
	notify('color shift set')
	z.lighting.ColorShift_Top = parse_hex(top) or Color3.new(0, 0, 0)
	z.lighting.ColorShift_Bottom = parse_hex(bottom) or Color3.new(0, 0, 0)
end)

cmd_library.add({'fpsboost', 'performancemode'}, 'optimizes game for better fps, might freeze your game for a moment', function()
	notify('applying fps boost')

	for _, v in pairs(workspace:GetDescendants()) do
		pcall(function()
			if v:IsA('BasePart') then
				v.Material = Enum.Material.SmoothPlastic
				v.Reflectance = 0
			elseif v:IsA('Decal') or v:IsA('Texture') then
				z.destroy(v)
			elseif v:IsA('ParticleEmitter') or v:IsA('Trail') or v:IsA('Smoke') or v:IsA('Fire') or v:IsA('Sparkles') then
				z.destroy(v)
			elseif v:IsA('MeshPart') then
				v.Material = Enum.Material.SmoothPlastic
				v.Reflectance = 0
				v.TextureID = ''
			elseif v:IsA('SpecialMesh') then
				v.TextureId = ''
			end
		end)
	end

	for _, v in pairs(z.lighting:GetChildren()) do
		if not v:IsA('Sky') and not v:IsA('Atmosphere') then
			pcall(z.destroy, v)
		end
	end

	pcall(function()
		z.lighting.GlobalShadows = false
		z.lighting.FogEnd = 100000
		z.lighting.Brightness = 1
	end)

	notify('fps boost applied')
end)

cmd_library.add({'copyid'}, '[player: string] - copies a player\'s user id to clipboard', function(_, name)
	local targets = get_plr(name)
	if not targets then
		return notify(`player '{name and tostring(name) or ''}' does not exist`)
	end

	local target = targets[1]
	setclipboard(tostring(target.UserId))
	notify(`copied {target.Name}'s id: {target.UserId}`)
end)

cmd_library.add({'copyplace'}, 'copies place id to clipboard', function()
	setclipboard(tostring(game.PlaceId))
	notify(`copied place id: {game.PlaceId}`)
end)

cmd_library.add({'copyjob'}, 'copies job id to clipboard', function()
	setclipboard(game.JobId)
	notify('copied job id')
end)

cmd_library.add({'coords', 'position', 'pos'}, 'shows your current position', function()
	local pos = z.local_character.HumanoidRootPart.Position
	notify(`position: {math.floor(pos.X)}, {math.floor(pos.Y)}, {math.floor(pos.Z)}`)
end)

cmd_library.add({'tpcoords', 'tpc'}, '[x: number, y: number, z: number] - teleport to coordinates', function(_, x, y, z_coord)
	x = tonumber(x) or 0
	y = tonumber(y) or 0
	z_coord = tonumber(z_coord) or 0

	notify(`teleporting to {x}, {y}, {z_coord}`)
	z.local_character:PivotTo(CFrame.new(x, y, z_coord))
end)

cmd_library.add({'trail'}, '[color: hex] - adds trail to character', function(vstorage, color)
	notify('trail added')

	local parsed = parse_hex(color) or Color3.fromRGB(255, 255, 255)

	for _, part in pairs(z.local_character:GetDescendants()) do
		if part:IsA('BasePart') and part.Name == 'HumanoidRootPart' then
			local trail = Instance.new('Trail')
			local a0 = Instance.new('Attachment', part)
			local a1 = Instance.new('Attachment', part)
			a0.Position = Vector3.new(0, part.Size.Y / 2, 0)
			a1.Position = Vector3.new(0, -part.Size.Y / 2, 0)
			trail.Attachment0 = a0
			trail.Attachment1 = a1
			trail.Color = ColorSequence.new(parsed)
			trail.Lifetime = 1
			trail.Parent = part
		end
	end
end)

cmd_library.add({'untrail'}, 'removes trail from character', function()
	notify('trail removed')

	for _, v in pairs(z.local_character:GetDescendants()) do
		if v:IsA('Trail') then
			z.destroy(v)
		end
	end
end)

cmd_library.add({'size', 'scale'}, '[size: number] - changes character size', function(_, size)
	size = tonumber(size) or 1
	notify(`size set to {size}`)

	z.local_character:ScaleTo(size)
end)

cmd_library.add({'spaz', 'seizure'}, 'makes your character spaz out', function(vstorage)
	if vstorage.enabled then
		return notify('spaz already enabled')
	end

	vstorage.enabled = true
	notify('spaz enabled')
	maid.add('spaz', z.run_service.Heartbeat, function()
		pcall(function()
			z.local_character.HumanoidRootPart.CFrame = z.local_character.HumanoidRootPart.CFrame * CFrame.Angles(
				math.rad(math.random(-90, 90)),
				math.rad(math.random(-90, 90)),
				math.rad(math.random(-90, 90))
			)
		end)
	end)
end)

cmd_library.add({'unspaz', 'unseizure'}, 'stops spaz', function()
	local vstorage = cmd_library.get_variable_storage('spaz')

	if not vstorage.enabled then
		return notify('spaz not enabled')
	end

	vstorage.enabled = false
	notify('spaz disabled')
	maid.remove('spaz')
end)

cmd_library.add({'clone'}, 'clones your character', function()
	notify('character cloned')
	z.local_character.Archivable = true
	local clone = z.local_character:Clone()
	clone.Parent = workspace

	for _, v in pairs(clone:GetDescendants()) do
		if v:IsA('Script') or v:IsA('LocalScript') then
			z.destroy(v)
		end
	end
end)

cmd_library.add({'removeclones', 'clearclones'}, 'removes all clones', function()
	notify('clones removed')

	for _, v in pairs(workspace:GetChildren()) do
		if v.Name == z.local_character.Name and v ~= z.local_character then
			z.destroy(v)
		end
	end
end)

cmd_library.add({'explode', 'explosion'}, '[size: number, blast_pressure: number] - creates explosion at your position', function(_, size,blastpressure)
	size = tonumber(size) or 10
	blastpressure = tonumber(blastpressure) or 500000
	notify(`exploding with size {size}`)

	local explosion = Instance.new('Explosion')
	explosion.Position = z.local_character.HumanoidRootPart.Position-Vector3.new(0,1,0)
	explosion.BlastRadius = size
	explosion.BlastPressure = blastpressure
	explosion.DestroyJointRadiusPercent = 0
	explosion.Parent = workspace
end)

cmd_library.add({'rocket', 'launch'}, '[power: number] - launches you like a rocket', function(_, power)
	power = tonumber(power) or 100
	notify(`launching with power {power}`)
	local bv = Instance.new('BodyVelocity')
	bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bv.Velocity = Vector3.new(0, power, 0)
	hypernull(function()
		bv.Parent = z.local_character.HumanoidRootPart
	end)

	z.debris:AddItem(bv, 0.5)
end)

cmd_library.add({'fixlighting', 'resetlighting'}, 'resets lighting', function()
	notify('lighting reset')

	z.lighting.Ambient = Color3.fromRGB(138, 138, 138)
	z.lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
	z.lighting.ColorShift_Top = Color3.new(0, 0, 0)
	z.lighting.ColorShift_Bottom = Color3.new(0, 0, 0)
	z.lighting.FogColor = Color3.fromRGB(191, 191, 191)
	z.lighting.FogEnd = 100000
	z.lighting.Brightness = 2
	z.lighting.ClockTime = 14
end)

cmd_library.add({'saveinstance', 'savegame'}, 'saves the game instance', function()
	notify('saving instance')
	saveinstance(game)
end)

cmd_library.add({'aimbot'}, '[fov: number] - aims at nearest player', function(vstorage, fov_size)
	if vstorage.enabled then
		return notify('aimbot already enabled')
	end

	vstorage.enabled = true
	vstorage.fov = tonumber(fov_size) or 200
	notify(`aimbot enabled with fov {vstorage.fov}`)

	maid.add('aimbot', z.run_service.RenderStepped, function()
		local target = get_closest_player(vstorage.fov)

		if target and target.Character and target.Character:FindFirstChild('Head') then
			workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, target.Character.Head.Position)
		end
	end)
end)

cmd_library.add({'unaimbot'}, 'disables aimbot', function()
	local vstorage = cmd_library.get_variable_storage('aimbot')

	if not vstorage.enabled then
		return notify('aimbot not enabled')
	end

	vstorage.enabled = false
	notify('aimbot disabled')
	maid.remove('aimbot')
end)

cmd_library.add({'showfov'}, '[fov: number, color: hex] - shows fov circle', function(vstorage, fov, color)
	fov = tonumber(fov) or 200

	if vstorage.enabled and vstorage.fov == fov then
		return notify('fov circle already enabled')
	end

	vstorage.fov = fov

	local fov_circle = vstorage.circle
	if fov_circle then
		z.destroy(fov_circle)
		vstorage.circle = nil
	end

	vstorage.enabled = true
	notify(`fov circle enabled with radius {fov}`)

	local fov_circle = Instance.new('ScreenGui', z.core_gui)
	fov_circle.Name = 'fov_circle'
	fov_circle.IgnoreGuiInset = true
	fov_circle.ResetOnSpawn = false
	vstorage.circle = fov_circle

	local circle = Instance.new('ImageLabel')
	circle.Image = 'rbxassetid://10131954007'
	circle.Size = UDim2.new(0, fov, 0, fov)
	circle.Position = UDim2.new(0.5, 0, 0.5, 0)
	circle.BackgroundTransparency = 1
	circle.ImageColor3 = color and parse_hex(color) or Color3.fromRGB(176, 126, 215)
	circle.ImageTransparency = 0
	circle.AnchorPoint = Vector2.new(0.5, 0.5)
	circle.Parent = fov_circle
end)

cmd_library.add({'hidefov'}, 'hides fov circle', function()
	local vstorage = cmd_library.get_variable_storage('showfov')

	if not vstorage.enabled then
		return notify('fov circle not enabled')
	end

	vstorage.enabled = false
	notify('fov circle disabled')

	local fov_circle = vstorage.circle
	if fov_circle then
		z.destroy(fov_circle)
		vstorage.circle = nil
	end
end)

cmd_library.add({'silentaim'}, '[fov: number] - silent aim at nearest player', function(vstorage, fov_size)
	if vstorage.enabled then
		return notify('silent aim already enabled')
	end

	vstorage.enabled = true
	vstorage.fov = tonumber(fov_size) or 200
	notify(`silent aim enabled with fov {vstorage.fov}`)

	vstorage.old_index = nil
	vstorage.old_index = hookmetamethod(game, '__index', function(self, key)
		if vstorage.enabled and self:IsA('Mouse') and (key == 'Hit' or key == 'Target') then
			local target = get_closest_player(vstorage.fov)

			if target and target.Character and target.Character:FindFirstChild('Head') then
				if key == 'Hit' then
					return target.Character.Head.CFrame
				elseif key == 'Target' then
					return target.Character.Head
				end
			end
		end

		return vstorage.old_index(self, key)
	end)
end)

cmd_library.add({'unsilentaim'}, 'disables silent aim', function()
	local vstorage = cmd_library.get_variable_storage('silentaim')

	if not vstorage.enabled then
		return notify('silent aim not enabled')
	end

	vstorage.enabled = false
	notify('silent aim disabled')
end)

cmd_library.add({'refresh', 'ref'}, 'respawns character at current position', function()
	notify('refreshing character')

	local old_pos = z.local_character:GetPivot()
	z.local_character:BreakJoints()

	task.wait(z.players.RespawnTime + 0.1)
	z.local_character:PivotTo(old_pos)
end)

cmd_library.add({'zerovelocity', 'zerovel', 'novel'}, 'stops all velocity on your character', function()
	notify('velocity stopped')

	for _, part in pairs(z.local_character:GetDescendants()) do
		if part:IsA('BasePart') then
			part.Velocity = Vector3.zero
			part.RotVelocity = Vector3.zero
			part.AssemblyLinearVelocity = Vector3.zero
			part.AssemblyAngularVelocity = Vector3.zero
		end
	end
end)

cmd_library.add({'removehats', 'removeaccessories', 'rhats'}, 'removes all accessories', function()
	notify('accessories removed')

	for _, v in pairs(z.local_character:GetDescendants()) do
		if v:IsA('Accessory') then
			z.destroy(v)
		end
	end
end)

cmd_library.add({'walkto', 'pathfind'}, '[player: string] - walks to a player', function(vstorage, name)
	local targets = get_plr(name)
	if not targets then
		return notify(`player '{name and tostring(name) or ''}' doesn't exist`)
	end

	local target = targets[1]
	if not target.Character or not target.Character:FindFirstChild('HumanoidRootPart') then
		return notify(`{target.Name} has no character`)
	end

	notify(`walking to {target.Name}`)
	z.local_character:FindFirstChildOfClass('Humanoid'):MoveTo(target.Character.HumanoidRootPart.Position)
end)

cmd_library.add({'stopwalkto', 'stoppath'}, 'stops walking', function()
	notify('stopped walking')
	z.local_character:FindFirstChildOfClass('Humanoid'):MoveTo(z.local_character.HumanoidRootPart.Position)
end)


cmd_library.add({'chat', 'say'}, '[message: string] - says something in chat', function(_, ...)
	local message = table.concat({...}, ' ')
	if message == '' then
		return notify('provide a message to say')
	end

	notify(`saying '{message}'`)

	if z.text_chat_service.ChatVersion == Enum.ChatVersion.TextChatService then
		z.text_chat_service.TextChannels.RBXGeneral:SendAsync(message)
	else
		z.replicated_storage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, 'All')
	end
end)

cmd_library.add({'spamchat'}, '[interval: number, message: string] - spams chat with a message', function(vstorage, interval, ...)
	if vstorage.enabled then
		return notify('spam chat already enabled')
	end

	local message = table.concat({...}, ' ')
	if message == '' then
		return notify('provide a message to spam')
	end
	interval = tonumber(interval) or .5

	vstorage.enabled = true
	vstorage.message = message
	notify(`spamming '{message}'`)

	while task.wait(interval) and vstorage.enabled do
		if z.text_chat_service.ChatVersion == Enum.ChatVersion.TextChatService then
			pcall(function()
				z.text_chat_service.TextChannels.RBXGeneral:SendAsync(vstorage.message)
			end)
		else
			pcall(function()
				z.replicated_storage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(vstorage.message, 'All')
			end)
		end
	end
end)

cmd_library.add({'unspamchat'}, 'stops spam chat', function()
	local vstorage = cmd_library.get_variable_storage('spamchat')

	if not vstorage.enabled then
		return notify('spam chat not enabled')
	end

	vstorage.enabled = false
	notify('spam chat disabled')
end)

cmd_library.add({'autopickup', 'apickup'}, '[range: number] - automatically picks up tools', function(vstorage, range)
	if vstorage.enabled then
		return notify('auto pickup already enabled')
	end

	range = range and tonumber(range) or 10

	vstorage.enabled = true
	notify('auto pickup enabled')

	maid.add('auto_pickup', z.run_service.Heartbeat, function()
		for _, v in pairs(workspace:GetDescendants()) do
			if v:IsA('Tool') and (z.local_character.HumanoidRootPart.Position - v.Handle.Position).Magnitude <= range then
				firetouchinterest(v.Handle)
			end
		end
	end)
end)

cmd_library.add({'unautopickup', 'unapickup'}, 'disables auto pickup', function()
	local vstorage = cmd_library.get_variable_storage('autopickup')

	if not vstorage.enabled then
		return notify('auto pickup not enabled')
	end

	vstorage.enabled = false
	notify('auto pickup disabled')
	maid.remove('auto_pickup')
end)

cmd_library.add({'spam'}, '[times: number, command: string] - spams a command', function(vstorage, times, ...)
	times = tonumber(times) or 10
	local args = {...}
	local cmd_name = args[1]
	table.remove(args, 1)

	notify(`spamming command '{cmd_name}' {times} times`)

	for i = 1, times do
		cmd_library.execute(cmd_name, unpack(args))
		task.wait(0.1)
	end
end)

cmd_library.add({'reach'}, '[size: number] - sets tool reach', function(vstorage, size)
	size = tonumber(size) or 10
	notify(`reach set to {size}`)
	pcall(function()
		maid.remove('reach')
	end)
	maid.add('reach', z.run_service.Heartbeat, function()
		for _, tool in pairs(z.local_character:GetChildren()) do
			if tool:IsA('Tool') and tool:FindFirstChild('Handle') then
				tool.Handle.Size = Vector3.new(size, size, size)
				tool.Handle.Transparency = .5
			end
		end
	end)
end)

cmd_library.add({'cframeloop', 'cfloop'}, '[speed: number] - cframe speed (fast movement)', function(vstorage, speed)
	if vstorage.enabled then
		return notify('cframe loop already enabled')
	end

	vstorage.enabled = true
	vstorage.speed = tonumber(speed) or 2
	notify(`cframe loop enabled with speed {vstorage.speed}`)
	pcall(function()
		maid.remove('cframe_loop')
	end)
	maid.add('cframe_loop', z.run_service.Heartbeat, function()
		pcall(function()
			local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
			if humanoid.MoveDirection.Magnitude > 0 then
				z.local_character.HumanoidRootPart.CFrame += humanoid.MoveDirection * vstorage.speed
			end
		end)
	end)
end)

cmd_library.add({'uncframeloop', 'uncfloop'}, 'stop cframe speed', function()
	local vstorage = cmd_library.get_variable_storage('cfloop')
	if not vstorage.enabled then
		return notify('cframe loop already disabled')
	end

	vstorage.enabled = false
	maid.remove('cframe_loop')
	notify(`cframe loop disabled`)
end)

cmd_library.add({'hncframeloop', 'hncfloop'}, '[speed: number] - cframe speed (bypass, laggy)', function(vstorage, speed)
	if vstorage.enabled then
		return notify('hn cframe loop already enabled')
	end

	vstorage.enabled = true
	vstorage.speed = tonumber(speed) or 2
	notify(`hn cframe loop enabled with speed {vstorage.speed}`)
	pcall(function()
		maid.remove('cframe_loop')
	end)
	maid.add('hn_cframe_loop', z.run_service.Heartbeat, function()
		pcall(function()
			local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
			if humanoid.MoveDirection.Magnitude > 0 then
				hypernull(function()
					z.local_character.HumanoidRootPart.CFrame += humanoid.MoveDirection * vstorage.speed
				end)
			end
		end)
	end)
end)

cmd_library.add({'discord','invite'}, 'copies the discord invite', function()
	if setclipboard then
		setclipboard('https://discord.gg/StHSWMjcnk')
		notify('discord invite copied to clipboard')
	end
end)

cmd_library.add({'unhncframeloop', 'unhncfloop'}, 'stop hn cframeloop', function()
	local vstorage = cmd_library.get_variable_storage('hncfloop')
	if not vstorage.enabled then
		return notify('hn cframe loop already disabled')
	end

	vstorage.enabled = false
	maid.remove('hn_cframe_loop')
	notify(`hn cframe loop disabled`)
end)

z.real_char, z.fakechars = nil, {}
cmd_library.add({'fakecharacter', 'fakechar', 'fc'}, 'creates a r6 fake character that you can control', function()
	notify('creating r6 fake character')

	local desc = z.players:GetHumanoidDescriptionFromUserId(z.local_player.UserId)
	local new_character = z.players:CreateHumanoidModelFromDescription(desc, Enum.HumanoidRigType.R6)
	new_character.Name = z.local_player.Name
	new_character.Humanoid.DisplayName = z.local_player.DisplayName

	if not z.real_char then
		z.real_char = z.local_character
		z.real_char.Parent = nil
	else
		table.insert(z.fakechars, z.local_character)
	end

	new_character:PivotTo(z.local_character:GetPivot())
	z.local_player.Character = new_character
	z.local_character = new_character
	new_character.Parent = workspace
end)

cmd_library.add({'r15fakecharacter', 'r15fakechar', 'r15fc'}, 'creates a r15 fake character that you can control', function()
	notify('creating r15 fake character')

	local desc = z.players:GetHumanoidDescriptionFromUserId(z.local_player.UserId)
	local new_character = z.players:CreateHumanoidModelFromDescription(desc, Enum.HumanoidRigType.R15)
	new_character.Name = z.local_player.Name
	new_character.Humanoid.DisplayName = z.local_player.DisplayName

	if not z.real_char then
		z.real_char = z.local_character
		z.real_char.Parent = nil
	else
		table.insert(z.fakechars, z.local_character)
	end

	new_character:PivotTo(z.local_character:GetPivot())
	z.local_player.Character = new_character
	z.local_character = new_character
	new_character.Parent = workspace
end)

cmd_library.add({'unfakecharacter', 'unfakechar', 'unfc'}, 'brings you back to your real character', function()
	if not z.real_char then
		return notify('you are not using a fake character')
	end

	notify('returning to real character')

	local current_pos = z.local_character:GetPivot()

	for _, fake in pairs(z.fakechars) do
		pcall(z.destroy, fake)
	end

	if z.local_character ~= z.real_char then
		pcall(z.destroy, z.local_character)
	end

	z.real_char.Parent = workspace
	z.local_player.Character = z.real_char
	z.local_character = z.real_char
	task.wait(0.2)
	z.real_char:PivotTo(current_pos)
	workspace.CurrentCamera.CameraSubject = z.real_char:FindFirstChildOfClass('Humanoid')

	for _, v in pairs(z.real_char:GetDescendants()) do
		if v:IsA('LocalScript') then
			v.Enabled = false
			v.Enabled = true
		end
	end

	table.clear(z.fakechars)
	z.real_char = nil
end)

cmd_library.add({'mirror', 'mimic'}, '[player: string, distance: number] - become their mirror and copy their movements', function(vstorage, name, distance)
	local targets = get_plr(name)
	if not targets or #targets == 0 then
		return notify(`player '{name and tostring(name) or ''}' doesn't exist`)
	end

	local target = targets[1]
	if not target.Character or not target.Character:FindFirstChild('HumanoidRootPart') then
		return notify(`{target.Name} has no character`)
	end

	if vstorage.target then
		return notify(`already mirroring {vstorage.target.Name}, use unmirror first`)
	end

	vstorage.target = target
	vstorage.distance = tonumber(distance) or 5

	notify(`now mirroring {target.Name}`)

	maid.add('mirror_connection', z.run_service.Heartbeat, function()
		pcall(function()
			if not vstorage.target or not vstorage.target.Character or not vstorage.target.Character:FindFirstChild('HumanoidRootPart') then
				maid.remove('mirror_connection')
				vstorage.target = nil
				return
			end

			local target_hrp = vstorage.target.Character.HumanoidRootPart
			local target_humanoid = vstorage.target.Character:FindFirstChildOfClass('Humanoid')
			local local_humanoid = z.local_character:FindFirstChildOfClass('Humanoid')

			if target_humanoid and local_humanoid then
				local offset = CFrame.new(0, 0, vstorage.distance)
				local mirror_cf = target_hrp.CFrame * offset

				z.local_character:PivotTo(mirror_cf)
				z.local_character.HumanoidRootPart.Velocity = Vector3.zero
				z.local_character.HumanoidRootPart.RotVelocity = Vector3.zero

				if target_humanoid.Jump then
					local_humanoid.Jump = true
				end

				if target_humanoid.Sit then
					local_humanoid.Sit = true
				end
			end
		end)
	end)
end)

cmd_library.add({'unmirror', 'unmimic'}, 'stop mirroring', function()
	local vstorage = cmd_library.get_variable_storage('mirror')

	if vstorage.target then
		notify(`stopped mirroring {vstorage.target.Name}`)
		vstorage.target = nil
		maid.remove('mirror_connection')
	else
		notify('you are not mirroring anyone')
	end
end)

cmd_library.add({'partstorm', 'pstorm', 'partrain'}, '[player: string, intensity: number] - rain parts on a player', function(vstorage, name, intensity)
	local targets = get_plr(name)
	if not targets or #targets == 0 then
		return notify(`player '{name and tostring(name) or ''}' doesn't exist`)
	end

	local target = targets[1]
	if not target.Character or not target.Character:FindFirstChild('HumanoidRootPart') then
		return notify(`{target.Name} has no character`)
	end

	if vstorage.enabled then
		return notify('partstorm already active, use unpartstorm first')
	end

	vstorage.enabled = true
	vstorage.intensity = tonumber(intensity) or 3
	vstorage.target = target

	notify(`raining parts on {target.Name}`)

	local old_cframe = z.local_character:GetPivot()
	z.local_character:WaitForChild('HumanoidRootPart').CFrame = old_cframe
	workspace.CurrentCamera = workspace.CurrentCamera
	task.wait(0.2)

	local parts = {}
	local part_limit = vstorage.intensity * 5

	for _, part in ipairs(workspace:GetDescendants()) do
		if part:IsA('BasePart') and not part.Anchored and #part:GetConnectedParts() < 2 then
			if not part.Parent:FindFirstChildOfClass('Humanoid') and not part.Parent.Parent:FindFirstChildOfClass('Humanoid') then
				if not part:IsDescendantOf(z.local_character) then
					table.insert(parts, part)
					if #parts >= part_limit then break end
				end
			end
		end
	end

	if #parts == 0 then
		vstorage.enabled = false
		return notify('no parts found for storm')
	end

	notify(`found {#parts} parts for storm`)

	maid.add('partstorm_connection', z.run_service.Heartbeat, function()
		if not vstorage.enabled then
			maid.remove('partstorm_connection')
			return
		end

		if not vstorage.target.Character or not vstorage.target.Character:FindFirstChild('HumanoidRootPart') then
			vstorage.enabled = false
			maid.remove('partstorm_connection')
			notify('target lost, stopping partstorm')
			return
		end

		local target_hrp = vstorage.target.Character.HumanoidRootPart

		for i = #parts, 1, -1 do
			local part = parts[i]

			if not part:IsDescendantOf(workspace) then
				table.remove(parts, i)
				continue
			end
			if part.ReceiveAge ~= 0 or part.Anchored then
				table.remove(parts, i)
				continue
			end
			pcall(function()
				part.CanCollide = true
				part.Velocity = Vector3.new(
					math.random(-50, 50),
					math.random(-100, 300),
					math.random(-50, 50)
				)

				local random_offset = Vector3.new(
					math.random(-20, 20),
					math.random(4, 30),
					math.random(-20, 20)
				)

				part.CFrame = CFrame.new(target_hrp.Position + random_offset)
			end)
		end

		if #parts == 0 then
			vstorage.enabled = false
			maid.remove('partstorm_connection')
			notify('partstorm ended, no more parts')
		end
	end)
end)

cmd_library.add({'unpartstorm', 'unpstorm', 'unpartrain'}, 'stops the part storm', function()
	local vstorage = cmd_library.get_variable_storage('partstorm')

	if not vstorage.enabled then
		return notify('partstorm is not active')
	end

	vstorage.enabled = false
	maid.remove('partstorm_connection')
	notify('partstorm stopped')
end)

cmd_library.add({'annoy'}, '[player: string, speed: number] - teleport spam around a player', function(vstorage, name, speed)
	local targets = get_plr(name)
	if not targets or #targets == 0 then
		return notify(`player '{name and tostring(name) or ''}' doesn't exist`)
	end

	local target = targets[1]
	if not target.Character or not target.Character:FindFirstChild('HumanoidRootPart') then
		return notify(`{target.Name} has no character`)
	end

	if vstorage.enabled then
		return notify('annoy already active, use unannoy first')
	end

	vstorage.enabled = true
	vstorage.target = target
	vstorage.speed = tonumber(speed) or 0.1

	notify(`now annoying {target.Name}`)

	local positions = {
		CFrame.new(5, 0, 0),
		CFrame.new(-5, 0, 0),
		CFrame.new(0, 5, 0),
		CFrame.new(0, -5, 0),
		CFrame.new(0, 0, 5),
		CFrame.new(0, 0, -5),
		CFrame.new(3, 3, 3),
		CFrame.new(-3, -3, -3)
	}

	local index = 1

	maid.add('annoy_connection', z.run_service.Heartbeat, function()
		if not vstorage.enabled then
			maid.remove('annoy_connection')
			return
		end

		if not vstorage.target.Character or not vstorage.target.Character:FindFirstChild('HumanoidRootPart') then
			vstorage.enabled = false
			maid.remove('annoy_connection')
			notify('target lost, stopping annoy')
			return
		end

		local target_hrp = vstorage.target.Character.HumanoidRootPart

		pcall(function()
			z.local_character:PivotTo(target_hrp.CFrame * positions[index])
			z.local_character.HumanoidRootPart.Velocity = Vector3.zero
		end)

		if tick() % vstorage.speed < 0.016 then
			index = index % #positions + 1
		end
	end)
end)

cmd_library.add({'unannoy'}, 'stops annoying', function()
	local vstorage = cmd_library.get_variable_storage('annoy')

	if not vstorage.enabled then
		return notify('annoy is not active')
	end

	vstorage.enabled = false
	maid.remove('annoy_connection')
	notify('stopped annoying')
end)

cmd_library.add({'btools','bt'},'vives client-sided btools',function()
	local Clone = Instance.new('HopperBin')
	local Hammer = Instance.new('HopperBin')
	local Grab = Instance.new('HopperBin')

	Clone.BinType = Enum.BinType.Clone
	Hammer.BinType = Enum.BinType.Hammer
	Grab.BinType = Enum.BinType.Grab

	Clone.Parent = z.local_player.Backpack
	Hammer.Parent = z.local_player.Backpack
	Grab.Parent = z.local_player.Backpack
	notify('gave btools')
end)

cmd_library.add({'antideath', 'antikill', 'autodeath'}, '[min_health: number] - teleports away from danger when health is low (default: 20)', function(vstorage, min_health)
	if vstorage.enabled then
		return notify('anti-death already enabled')
	end

	vstorage.enabled = true
	vstorage.min_health = tonumber(min_health) or 20
	notify(`anti-death enabled (threshold: {vstorage.min_health} HP)`)

	local function setup_antideath()
		local humanoid = z.local_character:FindFirstChildOfClass('Humanoid')
		if not humanoid then return end

		local last_health = humanoid.Health
		local safe_position = z.local_character:GetPivot()
		local damage_source = nil
		local teleport_count = 0
		local last_damage_tick = 0
		local is_escaping = false
		local last_teleport_time = 0

		local function find_damage_source()
			local hrp = z.local_character:FindFirstChild('HumanoidRootPart')
			if not hrp then return nil end

			local sources = {}

			for _, plr in pairs(z.players:GetPlayers()) do
				if plr ~= z.local_player and plr.Character and plr.Character:FindFirstChild('HumanoidRootPart') then
					local distance = (hrp.Position - plr.Character.HumanoidRootPart.Position).Magnitude
					if distance < 30 then
						local has_tool = plr.Character:FindFirstChildOfClass('Tool')
						table.insert(sources, {type = 'player', source = plr, name = plr.Name, distance = distance, priority = has_tool and 1 or 2})
					end
				end
			end

			for _, obj in pairs(workspace:GetDescendants()) do
				if obj:IsA('BasePart') and obj.Parent ~= z.local_character then
					local distance = (hrp.Position - obj.Position).Magnitude
					local obj_name = obj.Name:lower()

					if (obj_name:find('kill') or obj_name:find('damage') or obj_name:find('lava') or obj_name:find('death') or obj_name:find('fire') or obj_name:find('trap')) and distance < 25 then
						table.insert(sources, {type = 'hazard', source = obj, name = obj.Name, distance = distance, priority = 2})
					end

					if obj.Velocity.Magnitude > 60 and distance < 15 then
						table.insert(sources, {type = 'projectile', source = obj, name = obj.Name, distance = distance, priority = 1})
					end
				end
			end

			table.sort(sources, function(a, b)
				if a.priority == b.priority then
					return a.distance < b.distance
				end
				return a.priority < b.priority
			end)

			return sources[1]
		end

		local function teleport_to_safety()
			local hrp = z.local_character:FindFirstChild('HumanoidRootPart')
			if not hrp then return end

			if tick() - last_teleport_time < 0.15 then return end
			last_teleport_time = tick()

			teleport_count += 1
			is_escaping = true

			local escape_pos

			if damage_source then
				local source_pos

				if damage_source.type == 'player' and damage_source.source.Character and damage_source.source.Character:FindFirstChild('HumanoidRootPart') then
					source_pos = damage_source.source.Character.HumanoidRootPart.Position
					notify(`escaping from {damage_source.name}`)
				elseif damage_source.source and damage_source.source:IsA('BasePart') then
					source_pos = damage_source.source.Position
					notify(`escaping from {damage_source.type}`)
				end

				if source_pos then
					local escape_direction = (hrp.Position - source_pos).Unit
					local escape_distance = damage_source.type == 'player' and 70 or 50
					escape_pos = hrp.Position + (escape_direction * escape_distance) + Vector3.new(0, 20, 0)
				else
					escape_pos = safe_position.Position + Vector3.new(0, 10, 0)
				end
			else
				if (safe_position.Position - hrp.Position).Magnitude > 200 then
					local random_offset = Vector3.new(
						math.random(-80, 80),
						math.random(20, 50),
						math.random(-80, 80)
					)
					escape_pos = hrp.Position + random_offset
					notify('escaping to random position')
				else
					escape_pos = safe_position.Position + Vector3.new(0, 15, 0)
					notify('returning to safe position')
				end
			end

			for i = 1, 3 do
				pcall(function()
					z.local_character:PivotTo(CFrame.new(escape_pos))

					for _, part in pairs(z.local_character:GetDescendants()) do
						if part:IsA('BasePart') then
							part.Velocity = Vector3.zero
							part.AssemblyLinearVelocity = Vector3.zero
							part.AssemblyAngularVelocity = Vector3.zero
							part.RotVelocity = Vector3.zero
						end
					end
				end)

				if i < 3 then
					task.wait(0.05)
				end
			end

			task.delay(0.8, function()
				is_escaping = false
			end)
		end

		maid.add('antideath_health_monitor', humanoid:GetPropertyChangedSignal('Health'), function()
			if not vstorage.enabled then
				maid.remove('antideath_health_monitor')
				maid.remove('antideath_heartbeat')
				return
			end

			pcall(function()
				local current_health = humanoid.Health

				if current_health <= 0 then
					maid.remove('antideath_health_monitor')
					maid.remove('antideath_heartbeat')
					return
				end

				if current_health < last_health then
					last_damage_tick = tick()
					damage_source = find_damage_source()

					if current_health <= vstorage.min_health then
						teleport_to_safety()
					end
				end

				last_health = current_health
			end)
		end)

		maid.add('antideath_heartbeat', z.run_service.Heartbeat, function()
			if not vstorage.enabled then
				maid.remove('antideath_health_monitor')
				maid.remove('antideath_heartbeat')
				return
			end

			pcall(function()
				local current_health = humanoid.Health

				if current_health <= 0 then
					maid.remove('antideath_health_monitor')
					maid.remove('antideath_heartbeat')
					return
				end

				if current_health > vstorage.min_health + 40 and current_health >= last_health and not is_escaping then
					local hrp = z.local_character:FindFirstChild('HumanoidRootPart')
					if hrp and hrp.Position.Y > workspace.FallenPartsDestroyHeight + 50 then
						safe_position = z.local_character:GetPivot()
					end
				end

				if tick() - last_damage_tick < 2 and current_health <= vstorage.min_health then
					if not is_escaping then
						local health_before = current_health
						task.wait(0.15)

						if humanoid.Health < health_before and humanoid.Health > 0 then
							damage_source = find_damage_source()
							teleport_to_safety()
						end
					end
				end

				if tick() - last_damage_tick > 5 then
					teleport_count = 0
				end

				if teleport_count >= 10 then
					notify('excessive damage - returning to safe spawn')
					teleport_count = 0
					local spawn = workspace:FindFirstChild('SpawnLocation') or workspace:FindFirstChildOfClass('SpawnLocation')
					if spawn then
						z.local_character:PivotTo(spawn.CFrame + Vector3.new(0, 5, 0))
					else
						z.local_character:PivotTo(CFrame.new(0, 100, 0))
					end

					for _, part in pairs(z.local_character:GetDescendants()) do
						if part:IsA('BasePart') then
							part.Velocity = Vector3.zero
							part.AssemblyLinearVelocity = Vector3.zero
							part.AssemblyAngularVelocity = Vector3.zero
						end
					end
				end
			end)
		end)
	end

	setup_antideath()

	maid.add('antideath_character_respawn', z.local_player.CharacterAdded, function(character)
		if not vstorage.enabled then
			maid.remove('antideath_character_respawn')
			return
		end

		z.local_character = character
		task.wait(0.5)

		if vstorage.enabled then
			notify('anti-death reactivated after respawn')
			setup_antideath()
		end
	end)
end)

cmd_library.add({'unantideath', 'unantikill', 'stopantideath'}, 'disables anti-death', function()
	local vstorage = cmd_library.get_variable_storage('antideath')

	if not vstorage.enabled then
		return notify('anti-death not enabled')
	end

	vstorage.enabled = false
	notify('anti-death disabled')
	maid.remove('antideath_health_monitor')
	maid.remove('antideath_heartbeat')
	maid.remove('antideath_character_respawn')
end)

-- ui thing

local cmdbar_ui = ui.commandbox_ui:Clone()
cmdbar_ui:WaitForChild('main_container')
cmdbar_ui.Parent = game:GetService('CoreGui')

local main_container = cmdbar_ui.main_container
local cmdbox = main_container:WaitForChild('command_box')
local button = main_container:WaitForChild('mobile_open')
local pos_open_box = main_container.Position
local pos_open_button = button.Position
local pos_closed_box = UDim2.new(0.5, 0, 0, -35)
local pos_closed_button = UDim2.new(0.5, 0, 0, 10)
button.Visible = z.is_mobile

local tween_ui = function(element, duration, properties, close)
	z.tween_service:Create(element, TweenInfo.new(duration, Enum.EasingStyle.Sine, close and Enum.EasingDirection.Out or Enum.EasingDirection.In), properties):Play()
end

task.wait(.1)
tween_ui(main_container, 0.15, {Position = pos_closed_box}, true)
--tween_ui(button, 0.15, {Position = pos_closed_button}, true)
--die
local open = false
button.MouseButton1Click:Connect(function()
	open = not open
	if open then
		tween_ui(main_container, 0.15, {Position = pos_open_box}, false)
		--tween_ui(button, 0.15, {Position = pos_open_button}, false)
		button.Text = 'open'
		cmdbox:CaptureFocus()
	end
end)

maid.add('open_cmd_bar', z.user_input_service.InputBegan, function(k,i)
	if k.KeyCode == Enum.KeyCode.Quote and i == false then
		tween_ui(main_container, 0.15, {Position = pos_open_box}, false)
		--tween_ui(button, 0.15, {Position = pos_open_button}, false)
		open = true

		cmdbox:CaptureFocus()

		repeat
			cmdbox.Text = ''; z.run_service.Heartbeat:Wait()
		until cmdbox.Text == ''
	end
end,1)

cmdbox.FocusLost:Connect(function(enter)
	tween_ui(main_container, 0.1, {Position = pos_closed_box}, true)
	--tween_ui(button, 0.1, {Position = pos_closed_button}, true)
	open = false

	if not enter and not z.is_mobile then return end

	local text = cmdbox.Text
	if text ~= '' and text ~= ' ' then
		local args = text:split(' ')
		local cmd_name = args[1]
		table.remove(args, 1)

		cmd_library.execute(cmd_name, unpack(args))
	end

	cmdbox.Text = ''
end)

notify('join the discord .gg/StHSWMjcnk')
notify('opadmin loaded, press \' to open the cmdbar')
